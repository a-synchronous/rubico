/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,objectValues=Object.values,isPromise=r=>null!=r&&"function"==typeof r.then,__=Symbol.for("placeholder"),curry3ResolveArg0=(r,n,t)=>function(o){return r(o,n,t)},curry3ResolveArg1=(r,n,t)=>function(o){return r(n,o,t)},curry3ResolveArg2=(r,n,t)=>function(o){return r(n,t,o)},curry3=function(r,n,t,o){return n==__?curry3ResolveArg0(r,t,o):t==__?curry3ResolveArg1(r,n,o):curry3ResolveArg2(r,n,t)},thunkify3=(r,n,t,o)=>function(){return r(n,t,o)},thunkConditional=(r,n,t)=>r?n():t(),always=r=>function(){return r},arrayFindAsync=async function(r,n,t){const o=r.length;for(;++t<o;){const o=r[t];let e=n(o);if(isPromise(e)&&(e=await e),e)return o}},arrayFind=function(r,n){const t=r.length;let o=-1;for(;++o<t;){const t=r[o],e=n(t);if(isPromise(e))return e.then(curry3(thunkConditional,__,always(t),thunkify3(arrayFindAsync,r,n,o)));if(e)return t}},thunkify2=(r,n,t)=>function(){return r(n,t)},iteratorFindAsync=async function(r,n){let t=r.next();for(;!t.done;){const o=t.value;let e=n(o);if(isPromise(e)&&(e=await e),e)return o;t=r.next()}},iteratorFind=function(r,n){let t=r.next();for(;!t.done;){const o=t.value,e=n(o);if(isPromise(e))return e.then(curry3(thunkConditional,__,always(o),thunkify2(iteratorFindAsync,r,n)));if(e)return o;t=r.next()}},asyncIteratorFind=async function(r,n){let t=await r.next();for(;!t.done;){const o=t.value;let e=n(o);if(isPromise(e)&&(e=await e),e)return o;t=await r.next()}},find=r=>function(n){return isArray(n)?arrayFind(n,r):null!=n?"function"==typeof n[symbolIterator]?iteratorFind(n[symbolIterator](),r):"function"==typeof n[symbolAsyncIterator]?asyncIteratorFind(n[symbolAsyncIterator](),r):"function"==typeof n.find?n.find(r):n.constructor==Object?arrayFind(objectValues(n),r):void 0:void 0};export default find;
