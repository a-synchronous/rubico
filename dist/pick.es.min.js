/**
 * rubico v2.6.2
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,isArray=Array.isArray,memoizeCappedUnary=function(r,t){const e=new Map,n=function(n){if(e.has(n))return e.get(n);const i=r(n);return e.set(n,i),e.size>t&&e.clear(),i};return n.cache=e,n},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(r){const t=r.length-1,e="["==r[0],n="]"==r[t];return e&&n?r.slice(1,t).split(pathDelimiters):e?r.slice(1).split(pathDelimiters):n?r.slice(0,t).split(pathDelimiters):r.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=r=>isArray(r)?r:"string"==typeof r?memoizedCappedParsePropertyPath(r):[r],getByPath=function(r,t){const e=propertyPathToArray(t),n=e.length;let i=-1,o=r;for(;++i<n;)if(o=o[e[i]],null==o)return;return o},isObject=r=>{if(null==r)return!1;const t=typeof r;return"object"==t||"function"==t},setByPath=function(r,t,e){if(!isObject(r))return r;const n=propertyPathToArray(e),i=n.length,o=i-1,s={...r};let c=s,l=-1;for(;++l<i;){const r=n[l];if(l==o)c[r]=t;else{const t=c[r],e=isArray(t)?t.slice():{...t};c[r]=e,c=e}}return s},__=Symbol.for("placeholder"),curry2ResolveArg0=(r,t)=>function(e){return r(e,t)},curry2ResolveArg1=(r,t)=>function(e){return r(t,e)},curry2=function(r,t,e){return t==__?curry2ResolveArg0(r,e):curry2ResolveArg1(r,t)},_pick=function(r,t){if(null==r)return r;const e=t.length;let n={},i=-1;for(;++i<e;){const e=t[i],o=getByPath(r,e);null!=o&&(n=setByPath(n,o,e))}return n},pick=function(r,t){return null==t?curry2(_pick,__,r):isPromise(r)?r.then(curry2(_pick,__,t)):_pick(r,t)};export default pick;
