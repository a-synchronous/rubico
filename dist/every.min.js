/**
 * rubico v2.2.0
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2023 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(n,t){"object"==typeof module?module.exports=t:"function"==typeof define?define((()=>t)):n.every=t}("object"==typeof globalThis?globalThis:this,function(){"use strict";const n=n=>null!=n&&"function"==typeof n.then,t=Symbol.for("placeholder"),e=function(n,e,o){return e==t?((n,t)=>function(e){return n(e,t)})(n,o):((n,t)=>function(e){return n(t,e)})(n,e)},o=Array.isArray,r=function(n,e,o,r){return e==t?((n,t,e)=>function(o){return n(o,t,e)})(n,o,r):o==t?((n,t,e)=>function(o){return n(t,o,e)})(n,e,r):((n,t,e)=>function(o){return n(t,e,o)})(n,e,o)},u=Promise.all.bind(Promise),i=(n,t,e)=>n[t](e),c=function(e,o){const c=e.length,f=[];let s=-1;for(;++s<c;){const t=o(e[s]);if(n(t))f.push(t);else if(!t)return!1}return 0==f.length||u(f).then(r(i,t,"every",Boolean))},f=function(n){const t=n.then((n=>[n,t]));return t},s=Promise.race.bind(Promise),l=Object.values,a=(n,t,e)=>!!t&&n(e),y=Symbol.iterator,h=Symbol.asyncIterator,d=function(e,d){return o(e)?c(e,d):null==e?d(e):"function"==typeof e[y]?function(e,o){const c=[];for(const t of e){const e=o(t);if(n(e))c.push(e);else if(!e)return!1}return 0==c.length||u(c).then(r(i,t,"every",Boolean))}(e[y](),d):"function"==typeof e[h]?async function(t,e,o,r=20){let u=await t.next();for(;!u.done;){if(o.size>=r){const[n,t]=await s(o);if(o.delete(t),!n)return!1}const i=e(u.value);if(n(i))o.add(f(i));else if(!i)return!1;u=await t.next()}for(;o.size>0;){const[n,t]=await s(o);if(o.delete(t),!n)return!1}return!0}(e[h](),d,new Set):"function"==typeof e.reduce?e.reduce((e=>function(o,u){return!1!==o&&(n(o)?o.then(r(a,e,t,u)):!!o&&e(u))})(d),!0):e.constructor==Object?c(l(e),d):d(e)};return function(...o){const r=o.pop();if(0==o.length)return e(d,t,r);const u=o[0];return n(u)?u.then(e(d,t,r)):d(u,r)}}());
