/**
 * rubico v2.7.9
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2026 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,__=Symbol.for("placeholder"),curry3ResolveArg0=(r,e,t)=>function(n){return r(n,e,t)},curry3ResolveArg1=(r,e,t)=>function(n){return r(e,n,t)},curry3ResolveArg2=(r,e,t)=>function(n){return r(e,t,n)},curry3=function(r,e,t,n){return e==__?curry3ResolveArg0(r,t,n):t==__?curry3ResolveArg1(r,e,n):curry3ResolveArg2(r,e,t)},isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const e=typeof r;return"object"==e||"function"==e},memoizeCappedUnary=function(r,e){const t=new Map,n=function(n){if(t.has(n))return t.get(n);const o=r(n);return t.set(n,o),t.size>e&&t.clear(),o};return n.cache=t,n},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(r){const e=r.length-1,t="["==r[0],n="]"==r[e];return t&&n?r.slice(1,e).split(pathDelimiters):t?r.slice(1).split(pathDelimiters):n?r.slice(0,e).split(pathDelimiters):r.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=r=>isArray(r)?r:"string"==typeof r?memoizedCappedParsePropertyPath(r):[r],getByPath=function(r,e){const t=propertyPathToArray(e),n=t.length;let o=-1,i=r;for(;++o<n;)if(i=i[t[o]],null==i)return;return i},_get=function(r,e,t){const n=null==r?void 0:getByPath(r,e);return void 0===n?"function"==typeof t?t(r):t:n},get=function(r,e,t){return"string"==typeof r||"number"==typeof r||isArray(r)?curry3(_get,__,r,e):isPromise(r)?r.then(curry3(_get,__,e,t)):_get(r,e,t)};export default get;
