/**
 * rubico v2.7.9
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2026 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const e=typeof r;return"object"==e||"function"==e},memoizeCappedUnary=function(r,e){const t=new Map,n=function(n){if(t.has(n))return t.get(n);const s=r(n);return t.set(n,s),t.size>e&&t.clear(),s};return n.cache=t,n},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(r){const e=r.length-1,t="["==r[0],n="]"==r[e];return t&&n?r.slice(1,e).split(pathDelimiters):t?r.slice(1).split(pathDelimiters):n?r.slice(0,e).split(pathDelimiters):r.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=r=>isArray(r)?r:"string"==typeof r?memoizedCappedParsePropertyPath(r):[r],setByPath=function(r,e,t){if(!isObject(r))return r;const n=propertyPathToArray(t),s=n.length,i=s-1,o={...r};let c=o,u=-1;for(;++u<s;){const r=n[u];if(u==i)c[r]=e;else{const e=c[r],t=isArray(e)?e.slice():{...e};c[r]=t,c=t}}return o},__=Symbol.for("placeholder"),curry3ResolveArg0=(r,e,t)=>function(n){return r(n,e,t)},curry3ResolveArg1=(r,e,t)=>function(n){return r(e,n,t)},curry3ResolveArg2=(r,e,t)=>function(n){return r(e,t,n)},curry3=function(r,e,t,n){return e==__?curry3ResolveArg0(r,t,n):t==__?curry3ResolveArg1(r,e,n):curry3ResolveArg2(r,e,t)},_set=function(r,e,t){if("function"==typeof t){const n=t(r);return isPromise(n)?n.then(curry3(setByPath,r,__,e)):setByPath(r,n,e)}return isPromise(t)?t.then(curry3(setByPath,r,__,e)):setByPath(r,t,e)},set=function(r,e,t){return null==t?curry3(_set,__,r,e):isPromise(r)?r.then(curry3(_set,__,e,t)):_set(r,e,t)};export default set;
