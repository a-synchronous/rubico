/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isArray=Array.isArray,memoizeCappedUnary=function(e,t){const r=new Map,o=function(o){if(r.has(o))return r.get(o);const n=e(o);return r.set(o,n),r.size>t&&r.clear(),n};return o.cache=r,o},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(e){const t=e.length-1,r="["==e[0],o="]"==e[t];return r&&o?e.slice(1,t).split(pathDelimiters):r?e.slice(1).split(pathDelimiters):o?e.slice(0,t).split(pathDelimiters):e.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=e=>isArray(e)?e:"string"==typeof e?memoizedCappedParsePropertyPath(e):[e],getByPath=function(e,t){const r=propertyPathToArray(t),o=r.length;let n=-1,p=e;for(;++n<o;)if(p=p[r[n]],null==p)return;return p},deleteByPath=function(e,t){if(null==e)return;const r=propertyPathToArray(t),o=r.length-1;let n=-1,p=e;for(;++n<o;)if(p=p[r[n]],null==p)return;const a=r[n];null!=p&&a in p&&delete p[a]},objectCopyDeep=function(e){const t={};for(const r in e){const o=e[r];isArray(o)?t[r]=arrayCopyDeep(o):null!=o&&o.constructor==Object?t[r]=objectCopyDeep(o):t[r]=o}return t},arrayCopyDeep=function(e){const t=e.length,r=[];let o=-1;for(;++o<t;){const t=e[o];isArray(t)?r[o]=arrayCopyDeep(t):null!=t&&t.constructor==Object?r[o]=objectCopyDeep(t):r[o]=t}return r},copyDeep=function(e){return isArray(e)?arrayCopyDeep(e):null==e?e:e.constructor==Object?objectCopyDeep(e):e},omit=e=>function(t){const r=e.length,o=isArray(n=t)?arrayCopyDeep(n):null==n?n:n.constructor==Object?objectCopyDeep(n):n;var n;let p=-1;for(;++p<r;)deleteByPath(o,e[p]);return o};export default omit;
