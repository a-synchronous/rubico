/**
 * rubico v2.4.2
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(n,t){"object"==typeof module?module.exports=t:"function"==typeof define?define((()=>t)):n.map=t}("object"==typeof globalThis?globalThis:this,function(){"use strict";const n=n=>null!=n&&"function"==typeof n.then,t=Symbol.iterator,e=(n,e)=>({toString:()=>"[object MappingIterator]",[t](){return this},next(){const t=n.next();return t.done?t:{value:e(t.value),done:!1}}}),r=n=>({value:n,done:!1}),o=Symbol.asyncIterator,u=(t,e)=>({[o](){return this},async next(){const o=await t.next();if(o.done)return o;const u=e(o.value);return n(u)?u.then(r):{value:u,done:!1}}}),c=Symbol.for("placeholder"),i=function(n,t,e){return t==c?((n,t)=>function(e){return n(e,t)})(n,e):((n,t)=>function(e){return n(t,e)})(n,t)},f=Array.isArray,s=Promise.all.bind(Promise),h=function(t,e){const r=t.length,o=Array(r);let u=-1,c=!1;for(;++u<r;){const r=e(t[u],u,t);n(r)&&(c=!0),o[u]=r}return c?s(o):o},l=function(n,t,e,r){return t==c?((n,t,e)=>function(r){return n(r,t,e)})(n,e,r):e==c?((n,t,e)=>function(r){return n(t,r,e)})(n,t,r):((n,t,e)=>function(r){return n(t,e,r)})(n,t,e)},a=(n,t,e)=>n[t](e),p=n=>function(){return n},y=function(n,t,e,r,o){return t==c?((n,t,e,r)=>function(o){return n(o,t,e,r)})(n,e,r,o):e==c?((n,t,e,r)=>function(o){return n(t,o,e,r)})(n,t,r,o):r==c?((n,t,e,r)=>function(o){return n(t,e,o,r)})(n,t,e,o):((n,t,e,r)=>function(o){return n(t,e,r,o)})(n,t,e,r)},d=(n,t,e,r)=>n[t](e,r),g=t=>new Promise((t=>function(e){const r={};let o=0;for(const u in t){const c=t[u];n(c)?(o+=1,c.then((n=>function(t){r[n]=t,o-=1,0==o&&e(r)})(u))):r[u]=c}0==o&&e(r)})(t)),w=(t,e)=>function(...r){const o=t(...r);return n(o)?o.then(e):e(o)},b=function(n,t,e){return n[t]=e,n},m=async function(t,e,r,o){const u=t.length;for(;++o<u;){const u=e(t[o],o);r[o]=n(u)?await u:u}return r},j=n=>function(...t){return n(...t),t[0]},S=Promise.race.bind(Promise),v=async function(t,e,r,o,u,c){const i=t.length;for(;++u<i;){c.size>=r&&await S(c);const i=e(t[u]);if(n(i)){const n=i.then(j((()=>c.delete(n))));c.add(n),o[u]=n}else o[u]=i}return s(o)},A=(n,t,e)=>function(...r){const o=e.length,u=r.length,i=[];let f=-1,s=-1,h=0;for(;++f<o;){const o=e[f];if(o==c&&(s+=1)<u){const n=r[s];n==c&&(h+=1),i.push(n)}else i.push(o);if(i.length==n)return 0==h?t(...i):M(n,t,i)}for(;++s<u;){const e=r[s];if(e==c&&(h+=1),i.push(e),i.length==n)return 0==h?t(...i):M(n,t,i)}return M(n,t,i)},M=function(n,t,e){const r=e.length;if(r<n)return A(n,t,e);let o=-1;for(;++o<r;){if(e[o]==c)return A(n,t,e)}return t(...e)},T=n=>function([t,e]){return n(t,e)},x=function(n,t,e){return n.set(t,e)},E=function(t,e){const r=new Map,o=[];return t.forEach(((t,e,r)=>function(o,u){const c=t([u,o]);n(c)?r.push(c.then(T(M(3,x,[e])))):e.set(c[0],c[1])})(e,r,o)),0==o.length?r:s(o).then(p(r))},P=function(r,i){return f(r)?h(r,i):null==r?r:"function"==typeof r.then?r.then(i):"function"==typeof r.map?r.map(i):"string"==typeof r||r.constructor==String?function(t,e){const r=h(t,e);return n(r)?r.then(l(a,c,"join","")):r.join("")}(r,i):r.constructor==Set?function(t,e){const r=new Set,o=[];for(const u of t){const i=e(u,u,t);n(i)?o.push(i.then(l(a,r,"add",c))):r.add(i)}return 0==o.length?r:s(o).then(p(r))}(r,i):r.constructor==Map?function(t,e){const r=new Map,o=[];for(const[u,i]of t){const f=e(i,u,t);n(f)?o.push(f.then(y(d,r,"set",u,c))):r.set(u,f)}return 0==o.length?r:s(o).then(p(r))}(r,i):"function"==typeof r[t]?e(r[t](),i):"function"==typeof r[o]?u(r[o](),i):r.constructor==Object?function(t,e){const r={};let o=!1;for(const u in t){const c=e(t[u],u,t);n(c)&&(o=!0),r[u]=c}return o?g(r):r}(r,i):i(r)},O=function(t,e){return"function"==typeof t?i(P,c,t):n(t)?t.then(i(P,c,e)):P(t,e)},I=(t,e)=>{if(null==t)throw new TypeError("value is not an Object or Map");if(t.constructor==Object)return function(t,e){const r={},o=[];for(const u in t){const c=e([u,t[u]]);n(c)?o.push(c.then(T(M(3,b,[r])))):r[c[0]]=c[1]}return 0==o.length?r:s(o).then(p(r))}(t,e);if(t.constructor==Map)return E(t,e);throw new TypeError("value is not an Object or Map")};return O.entries=function(t,e){return"function"==typeof t?i(I,c,t):n(t)?t.then(i(I,c,e)):I(t,e)},O.series=t=>function(e){if(f(e))return function(t,e){const r=t.length,o=Array(r);let u=-1;for(;++u<r;){const r=e(t[u],u);if(n(r))return r.then(w(l(b,o,u,c),y(m,t,e,c,u)));o[u]=r}return o}(e,t);throw new TypeError(`${e} is not an Array`)},O.pool=(t,e)=>function(r){if(f(r))return function(t,e,r){const o=t.length,u=Array(o);let c=-1;for(;++c<o;){const o=e(t[c]);if(n(o)){const n=new Set,i=o.then(j((()=>n.delete(i))));return n.add(i),u[c]=i,v(t,e,r,u,c,n)}u[c]=o}return u}(r,e,t);throw new TypeError(`${r} is not an Array`)},O}());
