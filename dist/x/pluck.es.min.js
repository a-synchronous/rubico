/**
 * rubico v1.8.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,funcConcat=(r,t)=>function(...n){const e=r(...n);return isPromise(e)?e.then(t):t(e)},symbolIterator=Symbol.iterator,MappingIterator=(r,t)=>({toString:()=>"[object MappingIterator]",[symbolIterator](){return this},next(){const n=r.next();return n.done?n:{value:t(n.value),done:!1}}}),NextIteration=r=>({value:r,done:!1}),symbolAsyncIterator=Symbol.asyncIterator,MappingAsyncIterator=(r,t)=>({[symbolAsyncIterator](){return this},async next(){const n=await r.next();if(n.done)return n;const e=t(n.value);return isPromise(e)?e.then(NextIteration):{value:e,done:!1}}}),isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const t=typeof r;return"object"==t||"function"==t},objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=r=>nativeObjectToString.call(r),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=r=>objectToString(r)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=r=>objectToString(r)==asyncGeneratorFunctionTag,promiseAll=Promise.all.bind(Promise),arrayMap=function(r,t){const n=r.length,e=Array(n);let o=-1,c=!1;for(;++o<n;){const n=t(r[o],o,r);isPromise(n)&&(c=!0),e[o]=n}return c?promiseAll(e):e},generatorFunctionMap=(r,t)=>function*(...n){for(const e of r(...n))yield t(e)},asyncGeneratorFunctionMap=function(r,t){return async function*(...n){for await(const e of r(...n))yield t(e)}},__=Symbol.for("placeholder"),curry2ResolveArg0=(r,t)=>function(n){return r(n,t)},curry2ResolveArg1=(r,t)=>function(n){return r(t,n)},curry2=function(r,t,n){return t==__?curry2ResolveArg0(r,n):curry2ResolveArg1(r,t)},reducerMap=(r,t)=>function(n,e){const o=t(e);return isPromise(o)?o.then((c=r,a=__,(i=n)==__?curry2ResolveArg0(c,a):curry2ResolveArg1(c,i))):r(n,o);var c,i,a},curry3ResolveArg0=(r,t,n)=>function(e){return r(e,t,n)},curry3ResolveArg1=(r,t,n)=>function(e){return r(t,e,n)},curry3ResolveArg2=(r,t,n)=>function(e){return r(t,n,e)},curry3=function(r,t,n,e){return t==__?curry3ResolveArg0(r,n,e):n==__?curry3ResolveArg1(r,t,e):curry3ResolveArg2(r,t,n)},callPropUnary=(r,t,n)=>r[t](n),stringMap=function(r,t){const n=arrayMap(r,t);return isPromise(n)?n.then(curry3(callPropUnary,__,"join","")):n.join("")},always=r=>function(){return r},setMap=function(r,t){const n=new Set,e=[];for(const o of r){const c=t(o,o,r);isPromise(c)?e.push(c.then(curry3(callPropUnary,n,"add",__))):n.add(c)}return 0==e.length?n:promiseAll(e).then(always(n))},curry4ResolveArg0=(r,t,n,e)=>function(o){return r(o,t,n,e)},curry4ResolveArg1=(r,t,n,e)=>function(o){return r(t,o,n,e)},curry4ResolveArg2=(r,t,n,e)=>function(o){return r(t,n,o,e)},curry4ResolveArg3=(r,t,n,e)=>function(o){return r(t,n,e,o)},curry4=function(r,t,n,e,o){return t==__?curry4ResolveArg0(r,n,e,o):n==__?curry4ResolveArg1(r,t,e,o):e==__?curry4ResolveArg2(r,t,n,o):curry4ResolveArg3(r,t,n,e)},callPropBinary=(r,t,n,e)=>r[t](n,e),mapMap=function(r,t){const n=new Map,e=[];for(const[o,c]of r){const i=t(c,o,r);isPromise(i)?e.push(i.then(curry4(callPropBinary,n,"set",o,__))):n.set(o,i)}return 0==e.length?n:promiseAll(e).then(always(n))},promiseObjectAllExecutor=r=>function(t){const n={};let e=0;for(const o in r){const c=r[o];isPromise(c)?(e+=1,c.then((r=>function(o){n[r]=o,e-=1,0==e&&t(n)})(o))):n[o]=c}0==e&&t(n)},promiseObjectAll=r=>new Promise(promiseObjectAllExecutor(r)),objectMap=function(r,t){const n={};let e=!1;for(const o in r){const c=t(r[o],o,r);isPromise(c)&&(e=!0),n[o]=c}return e?promiseObjectAll(n):n},objectSet=function(r,t,n){return r[t]=n,r},arrayMapSeriesAsync=async function(r,t,n,e){const o=r.length;for(;++e<o;){const o=t(r[e]);n[e]=isPromise(o)?await o:o}return n},arrayMapSeries=function(r,t){const n=r.length,e=Array(n);let o=-1;for(;++o<n;){const n=t(r[o]);if(isPromise(n))return n.then(funcConcat(curry3(objectSet,e,o,__),curry4(arrayMapSeriesAsync,r,t,__,o)));e[o]=n}return e},tapSync=r=>function(...t){return r(...t),t[0]},promiseRace=Promise.race.bind(Promise),arrayMapPoolAsync=async function(r,t,n,e,o,c){const i=r.length;for(;++o<i;){c.size>=n&&await promiseRace(c);const i=t(r[o]);if(isPromise(i)){const r=i.then(tapSync((()=>c.delete(r))));c.add(r),e[o]=r}else e[o]=i}return promiseAll(e)},arrayMapPool=function(r,t,n){const e=r.length,o=Array(e);let c=-1;for(;++c<e;){const e=t(r[c]);if(isPromise(e)){const i=new Set,a=e.then(tapSync((()=>i.delete(a))));return i.add(a),o[c]=a,arrayMapPoolAsync(r,t,n,o,c,i)}o[c]=e}return o},arrayMapWithIndex=function(r,t){const n=r.length,e=Array(n);let o=-1,c=!1;for(;++o<n;){const n=t(r[o],o,r);isPromise(n)&&(c=!0),e[o]=n}return c?promiseAll(e):e},hasOwnProperty=Object.prototype.hasOwnProperty,hasOwn=(r,t)=>hasOwnProperty.call(r,t),objectMapOwn=function(r,t){const n={};let e=!1;for(const o in r)if(hasOwn(r,o)){const c=t(r[o]);isPromise(c)&&(e=!0),n[o]=c}return e?promiseObjectAll(n):n},_curryArity=(r,t,n)=>function(...e){const o=n.length,c=e.length,i=[];let a=-1,s=-1,u=0;for(;++a<o;){const o=n[a];if(o==__&&(s+=1)<c){const r=e[s];r==__&&(u+=1),i.push(r)}else i.push(o);if(i.length==r)return 0==u?t(...i):curryArity(r,t,i)}for(;++s<c;){const n=e[s];if(n==__&&(u+=1),i.push(n),i.length==r)return 0==u?t(...i):curryArity(r,t,i)}return curryArity(r,t,i)},curryArity=function(r,t,n){const e=n.length;if(e<r)return _curryArity(r,t,n);let o=-1;for(;++o<e;){if(n[o]==__)return _curryArity(r,t,n)}return t(...n)},spread2=r=>function([t,n]){return r(t,n)},objectMapEntries=function(r,t){const n={},e=[];for(const o in r){const c=t([o,r[o]]);isPromise(c)?e.push(c.then(spread2(curryArity(3,objectSet,[n])))):n[c[0]]=c[1]}return 0==e.length?n:promiseAll(e).then(always(n))},mapSet=function(r,t,n){return r.set(t,n)},mapMapEntriesForEachCallback=(r,t,n)=>function(e,o){const c=r([o,e]);isPromise(c)?n.push(c.then(spread2(curryArity(3,mapSet,[t])))):t.set(c[0],c[1])},mapMapEntries=function(r,t){const n=new Map,e=[];return r.forEach(mapMapEntriesForEachCallback(t,n,e)),0==e.length?n:promiseAll(e).then(always(n))},map=r=>function(t){return isArray(t)?arrayMap(t,r):"function"==typeof t?isGeneratorFunction(t)?generatorFunctionMap(t,r):isAsyncGeneratorFunction(t)?asyncGeneratorFunctionMap(t,r):reducerMap(t,r):null==t?t:"function"==typeof t.then?t.then(r):"function"==typeof t.map?t.map(r):"string"==typeof t||t.constructor==String?stringMap(t,r):t.constructor==Set?setMap(t,r):t.constructor==Map?mapMap(t,r):t.constructor==Object?objectMap(t,r):"function"==typeof t[symbolIterator]?MappingIterator(t[symbolIterator](),r):"function"==typeof t[symbolAsyncIterator]?MappingAsyncIterator(t[symbolAsyncIterator](),r):r(t)};map.entries=function(r){return function(t){if(null==t)throw new TypeError("value is not an Object or Map");if(t.constructor==Object)return objectMapEntries(t,r);if(t.constructor==Map)return mapMapEntries(t,r);throw new TypeError("value is not an Object or Map")}},map.series=r=>function(t){if(isArray(t))return arrayMapSeries(t,r);throw new TypeError(`${t} is not an Array`)},map.pool=(r,t)=>function(n){if(isArray(n))return arrayMapPool(n,t,r);throw new TypeError(`${n} is not an Array`)},map.withIndex=r=>function(t){if(isArray(t))return arrayMapWithIndex(t,r);throw new TypeError(`${t} is not an Array`)},map.own=r=>function(t){if(isObject(t)&&!isArray(t))return objectMapOwn(t,r);throw new TypeError(`${t} is not an Object`)};const memoizeCappedUnary=function(r,t){const n=new Map,e=function(e){if(n.has(e))return n.get(e);const o=r(e);return n.set(e,o),n.size>t&&n.clear(),o};return e.cache=n,e},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(r){const t=r.length-1,n="["==r[0],e="]"==r[t];return n&&e?r.slice(1,t).split(pathDelimiters):n?r.slice(1).split(pathDelimiters):e?r.slice(0,t).split(pathDelimiters):r.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=r=>isArray(r)?r:"string"==typeof r?memoizedCappedParsePropertyPath(r):[r],getByPath=function(r,t){const n=propertyPathToArray(t),e=n.length;let o=-1,c=r;for(;++o<e;)if(c=c[n[o]],null==c)return;return c},get=(r,t)=>function(n){const e=null==n?void 0:getByPath(n,r);return void 0===e?"function"==typeof t?t(n):t:e},pluck=funcConcat(get,map);export default pluck;
