/**
 * rubico v2.3.6
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(t,n){"object"==typeof module?module.exports=n:"function"==typeof define?define((()=>n)):t.some=n}("object"==typeof globalThis?globalThis:this,function(){"use strict";const t=t=>null!=t&&"function"==typeof t.then,n=Symbol.for("placeholder"),e=function(t,e,r){return e==n?((t,n)=>function(e){return t(e,n)})(t,r):((t,n)=>function(e){return t(n,e)})(t,e)},r=Array.isArray,o=Object.values,u=function(t){const n=t.then((t=>[t,n]));return n},i=Promise.race.bind(Promise),f=async function(n,e,r,o){const f=n.length;for(;++r<f;){const i=e(n[r]);if(t(i))o.add(u(i));else if(i)return!0}for(;o.size>0;){const[t,n]=await i(o);if(o.delete(n),t)return!0}return!1},c=function(n,e){const r=n.length;let o=-1;for(;++o<r;){const r=e(n[o]);if(t(r))return f(n,e,o,new Set([u(r)]));if(r)return!0}return!1},s=async function(n,e,r,o=20){let f=n.next();for(t(f)&&(f=await f);!f.done;){if(r.size>=o){const[t,n]=await i(r);if(r.delete(n),t)return!0}const c=e(f.value);if(t(c))r.add(u(c));else if(c)return!0;f=n.next(),t(f)&&(f=await f)}for(;r.size>0;){const[t,n]=await i(r);if(r.delete(n),t)return!0}return!1},l=Symbol.iterator,a=Symbol.asyncIterator,d=function(i,f){return r(i)?c(i,f):null==i?f(i):"function"==typeof i[l]?function(n,e){for(const r of n){const o=e(r);if(t(o))return s(n,e,new Set([u(o)]));if(o)return!0}return!1}(i[l](),f):"function"==typeof i[a]?s(i[a](),f,new Set):"function"==typeof i.reduce?i.reduce((r=>function(o,u){return!0===o?o:t(o)?o.then(e((t=>function(n,e){return!!n||t(e)})(r),n,u)):!!o||r(u)})(f),!1):i.constructor==Object?c(o(i),f):f(i)};return function(...r){const o=r.pop();if(0==r.length)return e(d,n,o);const u=r[0];return t(u)?u.then(e(d,n,o)):d(u,o)}}());
