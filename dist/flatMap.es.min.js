/**
 * rubico v2.7.9
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2026 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=e=>null!=e&&"function"==typeof e.then,isArray=Array.isArray,objectValues=Object.values,objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=e=>nativeObjectToString.call(e),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=e=>objectToString(e)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=e=>objectToString(e)==asyncGeneratorFunctionTag,__=Symbol.for("placeholder"),curry3ResolveArg0=(e,r,t)=>function(n){return e(n,r,t)},curry3ResolveArg1=(e,r,t)=>function(n){return e(r,n,t)},curry3ResolveArg2=(e,r,t)=>function(n){return e(r,t,n)},curry3=function(e,r,t,n){return r==__?curry3ResolveArg0(e,t,n):t==__?curry3ResolveArg1(e,r,n):curry3ResolveArg2(e,r,t)},iteratorReduceAsync=async function(e,r,t){let n=e.next();if(n.done)return t;for(;!n.done;)t=r(t,n.value),isPromise(t)&&(t=await t),n=e.next();return t},iteratorReduce=function(e,r,t){let n=e.next();if(n.done)return t;for(void 0===t&&(t=n.value,n=e.next());!n.done;){if(t=r(t,n.value),isPromise(t))return t.then(curry3(iteratorReduceAsync,e,r,__));n=e.next()}return t},asyncIteratorReduce=async function(e,r,t){let n=await e.next();if(n.done)return t;for(void 0===t&&(t=n.value,n=await e.next());!n.done;)t=await r(t,n.value),n=await e.next();return t},symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,curry2ResolveArg0=(e,r)=>function(t){return e(t,r)},curry2ResolveArg1=(e,r)=>function(t){return e(r,t)},curry2=function(e,r,t){return r==__?curry2ResolveArg0(e,t):curry2ResolveArg1(e,r)},curryArgs3ResolveArgs0=(e,r,t)=>function(...n){return e(n,r,t)},curryArgs3ResolveArgs1=(e,r,t)=>function(...n){return e(r,n,t)},curryArgs3ResolveArgs2=(e,r,t)=>function(...n){return e(r,t,n)},curryArgs3=function(e,r,t,n){return r==__?curryArgs3ResolveArgs0(e,t,n):t==__?curryArgs3ResolveArgs1(e,r,n):curryArgs3ResolveArgs2(e,r,t)},curry4ResolveArg0=(e,r,t,n)=>function(o){return e(o,r,t,n)},curry4ResolveArg1=(e,r,t,n)=>function(o){return e(r,o,t,n)},curry4ResolveArg2=(e,r,t,n)=>function(o){return e(r,t,o,n)},curry4ResolveArg3=(e,r,t,n)=>function(o){return e(r,t,n,o)},curry4=function(e,r,t,n,o){return r==__?curry4ResolveArg0(e,t,n,o):t==__?curry4ResolveArg1(e,r,n,o):n==__?curry4ResolveArg2(e,r,t,o):curry4ResolveArg3(e,r,t,n)},arrayReduceAsync=async function(e,r,t,n){const o=e.length;for(;++n<o;)t=r(t,e[n],n,e),isPromise(t)&&(t=await t);return t},arrayReduce=function(e,r,t){const n=e.length;let o=-1;for(void 0===t&&(t=e[++o]);++o<n;)if(t=r(t,e[o],o,e),isPromise(t))return t.then(curry4(arrayReduceAsync,e,r,__,o));return t},curry5ResolveArg0=(e,r,t,n,o)=>function(c){return e(c,r,t,n,o)},curry5ResolveArg1=(e,r,t,n,o)=>function(c){return e(r,c,t,n,o)},curry5ResolveArg2=(e,r,t,n,o)=>function(c){return e(r,t,c,n,o)},curry5ResolveArg3=(e,r,t,n,o)=>function(c){return e(r,t,n,c,o)},curry5ResolveArg4=(e,r,t,n,o)=>function(c){return e(r,t,n,o,c)},curry5=function(e,r,t,n,o,c){return r==__?curry5ResolveArg0(e,t,n,o,c):t==__?curry5ResolveArg1(e,r,n,o,c):n==__?curry5ResolveArg2(e,r,t,o,c):o==__?curry5ResolveArg3(e,r,t,n,c):curry5ResolveArg4(e,r,t,n,o)},objectKeys=Object.keys,objectReduceAsync=async function(e,r,t,n,o){const c=n.length;for(;++o<c;){const c=n[o];t=r(t,e[c],c,e),isPromise(t)&&(t=await t)}return t},objectReduce=function(e,r,t){const n=objectKeys(e),o=n.length;let c=-1;for(void 0===t&&(t=e[n[++c]]);++c<o;){const o=n[c];if(t=r(t,e[o],o,e),isPromise(t))return t.then(curry5(objectReduceAsync,e,r,__,n,c))}return t},mapReduceAsync=async function(e,r,t,n){for(const[o,c]of n)t=r(t,c,o,e),isPromise(t)&&(t=await t);return t},mapReduce=function(e,r,t){const n=e.entries();if(void 0===t){const e=n.next();if(e.done)return t;t=e.value[1]}for(const[o,c]of n)if(t=r(t,c,o,e),isPromise(t))return t.then(curry4(mapReduceAsync,e,r,__,n));return t},reducerConcat=(e,r)=>function(t,n){const o=e(t,n);return isPromise(o)?o.then(curry2(r,__,n)):r(o,n)},genericReduce=function(e,r,t){return isArray(e)?arrayReduce(e,r,t):null==e?void 0===t?curry2(r,e,__):r(t,e):e.constructor==Map?mapReduce(e,r,t):"function"==typeof e[symbolIterator]?iteratorReduce(e[symbolIterator](),r,t):"function"==typeof e[symbolAsyncIterator]?asyncIteratorReduce(e[symbolAsyncIterator](),r,t):"function"==typeof e.reduce?e.reduce(r,t):"function"==typeof e.chain?e.chain(curry2(r,t,__)):"function"==typeof e.flatMap?e.flatMap(curry2(r,t,__)):e.constructor==Object?objectReduce(e,r,t):void 0===t?curry2(r,e,__):r(t,e)},arrayPush=function(e,r){return e.push(r),e},FlatMappingIterator=function(e,r){let t=[],n=0;return{[symbolIterator](){return this},next(){if(n<t.length){const e=t[n];return n+=1,{value:e,done:!1}}const o=e.next();if(o.done)return o;const c=genericReduce(r(o.value),arrayPush,[]);return c.length>1&&(t=c,n=1),{value:c[0],done:!1}}}},promiseRace=Promise.race.bind(Promise),sleep=e=>new Promise((r=>{setTimeout(r,e)})),FlatMappingAsyncIterator=function(e,r){const t=[],n=new Set;return{isAsyncIteratorDone:!1,[symbolAsyncIterator](){return this},toString:()=>"[object FlatMappingAsyncIterator]",async next(){for(;!this.isAsyncIteratorDone||t.length>0||n.size>0;){if(!this.isAsyncIteratorDone){const{value:o,done:c}=await e.next();if(c)this.isAsyncIteratorDone=c;else{const e=r(o);if(isPromise(e)){const r=e.then(curry3(genericReduce,__,arrayPush,t)).then((()=>n.delete(r)));n.add(r)}else{const r=genericReduce(e,arrayPush,t);if(isPromise(r)){const e=r.then((()=>n.delete(e)));n.add(e)}}}}if(t.length>0)return{value:t.shift(),done:!1};n.size>0&&await promiseRace([sleep(1e3),...n])}return{value:void 0,done:!0}}}},always=e=>function(){return e},getArg1=(e,r)=>r,identity=e=>e,promiseAll=Promise.all.bind(Promise),funcConcatSync=(e,r)=>function(...t){return r(e(...t))},asyncIteratorForEach=async function(e,r){const t=[];for await(const n of e){const e=r(n);isPromise(e)&&t.push(e)}return 0==t.length?e:promiseAll(t).then(always(e))},arrayFlatten=function(e){const r=e.length,t=[],n=[];let o=-1;for(;++o<r;){const r=e[o];if(isArray(r)){const e=r.length;let t=-1;for(;++t<e;)n.push(r[t])}else if(null==r)n.push(r);else if("function"==typeof r.then)t.push(r.then(curry2(arrayPush,n,__)));else if("function"==typeof r[symbolIterator])for(const e of r)n.push(e);else if("function"==typeof r[symbolAsyncIterator])t.push(asyncIteratorForEach(r[symbolAsyncIterator](),curry2(arrayPush,n,__)));else if("function"==typeof r.chain){const e=r.chain(identity);isPromise(e)?t.push(e.then(curry2(arrayPush,n,__))):n.push(e)}else if("function"==typeof r.flatMap){const e=r.flatMap(identity);isPromise(e)?t.push(e.then(curry2(arrayPush,n,__))):n.push(e)}else if("function"==typeof r.reduce){const e=r.reduce(funcConcatSync(getArg1,curry2(arrayPush,n,__)),null);isPromise(e)&&t.push(e)}else if(r.constructor==Object)for(const e in r)n.push(r[e]);else n.push(r)}return 0==t.length?n:promiseAll(t).then(always(n))},arrayMap=function(e,r){const t=e.length,n=Array(t);let o=-1,c=!1;for(;++o<t;){const t=r(e[o],o,e);isPromise(t)&&(c=!0),n[o]=t}return c?promiseAll(n):n},arrayFlatMap=function(e,r){const t=arrayMap(e,r);return isPromise(t)?t.then(arrayFlatten):arrayFlatten(t)},promiseObjectAllExecutor=e=>function(r){const t={};let n=0;for(const o in e){const c=e[o];isPromise(c)?(n+=1,c.then((e=>function(o){t[e]=o,n-=1,0==n&&r(t)})(o))):t[o]=c}0==n&&r(t)},promiseObjectAll=e=>new Promise(promiseObjectAllExecutor(e)),objectMap=function(e,r){const t={};let n=!1;for(const o in e){const c=r(e[o],o,e);isPromise(c)&&(n=!0),t[o]=c}return n?promiseObjectAll(t):t},objectAssign=Object.assign,objectFlatten=function(e){const r=[],t={},n=curry2(objectAssign,t,__),o=funcConcatSync(getArg1,n);for(const c in e){const s=e[c];if(null!=s)if("function"==typeof s[symbolIterator])for(const e of s)objectAssign(t,e);else if("function"==typeof s[symbolAsyncIterator])r.push(asyncIteratorForEach(s[symbolAsyncIterator](),n));else if("function"==typeof s.chain){const e=s.chain(identity);isPromise(e)?r.push(e.then(n)):objectAssign(t,e)}else if("function"==typeof s.flatMap){const e=s.flatMap(identity);isPromise(e)?r.push(e.then(n)):n(e)}else if("function"==typeof s.reduce){const e=s.reduce(o,null);isPromise(e)&&r.push(e)}else objectAssign(t,s)}return 0==r.length?t:promiseAll(r).then((()=>t))},objectFlatMap=function(e,r){const t=objectMap(e,r);return isPromise(t)?t.then(objectFlatten):objectFlatten(t)},callPropUnary=(e,r,t)=>e[r](t),setMap=function(e,r){const t=new Set,n=[];for(const o of e){const c=r(o,o,e);isPromise(c)?n.push(c.then(curry3(callPropUnary,t,"add",__))):t.add(c)}return 0==n.length?t:promiseAll(n).then(always(t))},setFlatten=function(e){e.size;const r=[],t=new Set,n=(e,r)=>t.add(r),o=curry3(callPropUnary,t,"add",__);for(const c of e)if(isArray(c)){const e=c.length;let r=-1;for(;++r<e;)t.add(c[r])}else if(null==c)t.add(c);else if("function"==typeof c[symbolIterator])for(const e of c)t.add(e);else if("function"==typeof c[symbolAsyncIterator])r.push(asyncIteratorForEach(c[symbolAsyncIterator](),o));else if("function"==typeof c.chain){const e=c.chain(identity);isPromise(e)?r.push(e.then(o)):t.add(e)}else if("function"==typeof c.flatMap){const e=c.flatMap(identity);isPromise(e)?r.push(e.then(o)):t.add(e)}else if("function"==typeof c.reduce){const e=c.reduce(n,null);isPromise(e)&&r.push(e)}else if(c.constructor==Object)for(const e in c)t.add(c[e]);else t.add(c);return 0==r.length?t:promiseAll(r).then((()=>t))},setFlatMap=function(e,r){const t=setMap(e,r);return isPromise(t)?t.then(setFlatten):setFlatten(t)},funcConcat=(e,r)=>function(...t){const n=e(...t);return isPromise(n)?n.then(r):r(n)},arrayJoin=(e,r)=>e.join(r),arrayFlattenToString=funcConcat(arrayFlatten,curry2(arrayJoin,__,"")),stringFlatMap=function(e,r){const t=arrayMap(e,r);return isPromise(t)?t.then(arrayFlattenToString):arrayFlattenToString(t)},_flatMap=function(e,r){if(isArray(e))return arrayFlatMap(e,r);if(null==e)return r(e);if("function"==typeof e.then)return e.then(r);if("function"==typeof e.next)return symbolIterator in e?FlatMappingIterator(e,r):FlatMappingAsyncIterator(e,r);if("function"==typeof e.chain)return e.chain(r);if("function"==typeof e.flatMap)return e.flatMap(r);const t=e.constructor;return t==Object?objectFlatMap(e,r):t==Set?setFlatMap(e,r):"string"==typeof e||t==String?stringFlatMap(e,r):r(e)},flatMap=(e,r)=>"function"==typeof e?curry2(_flatMap,__,e):isPromise(e)?e.then(curry2(_flatMap,__,r)):_flatMap(e,r);export default flatMap;
