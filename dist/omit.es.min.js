/**
 * rubico v2.6.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=e=>null!=e&&"function"==typeof e.then,isArray=Array.isArray,memoizeCappedUnary=function(e,r){const t=new Map,o=function(o){if(t.has(o))return t.get(o);const n=e(o);return t.set(o,n),t.size>r&&t.clear(),n};return o.cache=t,o},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(e){const r=e.length-1,t="["==e[0],o="]"==e[r];return t&&o?e.slice(1,r).split(pathDelimiters):t?e.slice(1).split(pathDelimiters):o?e.slice(0,r).split(pathDelimiters):e.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=e=>isArray(e)?e:"string"==typeof e?memoizedCappedParsePropertyPath(e):[e],getByPath=function(e,r){const t=propertyPathToArray(r),o=t.length;let n=-1,i=e;for(;++n<o;)if(i=i[t[n]],null==i)return;return i},deleteByPath=function(e,r){if(null==e)return;const t=propertyPathToArray(r),o=t.length-1;let n=-1,i=e;for(;++n<o;)if(i=i[t[n]],null==i)return;const c=t[n];null!=i&&c in i&&delete i[c]},objectCopyDeep=function(e){const r={};for(const t in e){const o=e[t];isArray(o)?r[t]=arrayCopyDeep(o):null!=o&&o.constructor==Object?r[t]=objectCopyDeep(o):r[t]=o}return r},arrayCopyDeep=function(e){const r=e.length,t=[];let o=-1;for(;++o<r;){const r=e[o];isArray(r)?t[o]=arrayCopyDeep(r):null!=r&&r.constructor==Object?t[o]=objectCopyDeep(r):t[o]=r}return t},copyDeep=function(e){return isArray(e)?arrayCopyDeep(e):null==e?e:e.constructor==Object?objectCopyDeep(e):e},__=Symbol.for("placeholder"),curry2ResolveArg0=(e,r)=>function(t){return e(t,r)},curry2ResolveArg1=(e,r)=>function(t){return e(r,t)},curry2=function(e,r,t){return r==__?curry2ResolveArg0(e,t):curry2ResolveArg1(e,r)},_omit=function(e,r){const t=r.length,o=copyDeep(e);let n=-1;for(;++n<t;)deleteByPath(o,r[n]);return o},omit=function(e,r){return null==r?curry2(_omit,__,e):isPromise(e)?e.then(curry2(_omit,__,r)):_omit(e,r)};export default omit;
