/**
 * rubico v2.3.6
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const __=Symbol.for("placeholder"),curry2ResolveArg0=(r,e)=>function(n){return r(n,e)},curry2ResolveArg1=(r,e)=>function(n){return r(e,n)},curry2=function(r,e,n){return e==__?curry2ResolveArg0(r,n):curry2ResolveArg1(r,e)},curry3ResolveArg0=(r,e,n)=>function(t){return r(t,e,n)},curry3ResolveArg1=(r,e,n)=>function(t){return r(e,t,n)},curry3ResolveArg2=(r,e,n)=>function(t){return r(e,n,t)},curry3=function(r,e,n,t){return e==__?curry3ResolveArg0(r,n,t):n==__?curry3ResolveArg1(r,e,t):curry3ResolveArg2(r,e,n)},thunkify2=(r,e,n)=>function(){return r(e,n)},thunkify5=(r,e,n,t,o,i)=>function(){return r(e,n,t,o,i)},thunkConditional=(r,e,n)=>r?e():n(),isPromise=r=>null!=r&&"function"==typeof r.then,isArray=Array.isArray,SelfReferencingPromise=function(r){const e=r.then((r=>[r,e]));return e},promiseRace=Promise.race.bind(Promise),asyncArraySome=async function(r,e,n,t){const o=r.length;for(;++n<o;){const o=e(r[n]);if(isPromise(o))t.add(SelfReferencingPromise(o));else if(o)return!0}for(;t.size>0;){const[r,e]=await promiseRace(t);if(t.delete(e),r)return!0}return!1},arraySome=function(r,e){const n=r.length;let t=-1;for(;++t<n;){const n=e(r[t]);if(isPromise(n))return asyncArraySome(r,e,t,new Set([SelfReferencingPromise(n)]));if(n)return!0}return!1},arrayPush=function(r,e){return r.push(e),r},funcConcatSync=(r,e)=>function(...n){return e(r(...n))},noop=function(){},symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,differenceWithArrayAsync=async function(r,e,n,t,o){const i=e.length;for(;++o<i;){const i=e[o];let c=arraySome(n,curry2(r,i,__));isPromise(c)&&(c=await c),c||t.push(i)}return t},differenceWithArray=function(r,e,n){const t=e.length,o=[];let i=-1;for(;++i<t;){const t=e[i],y=arraySome(n,curry2(r,t,__));if(isPromise(y))return y.then(funcConcatSync((c=thunkConditional,u=__,s=noop,f=thunkify2(arrayPush,o,t),u==__?curry3ResolveArg0(c,s,f):s==__?curry3ResolveArg1(c,u,f):curry3ResolveArg2(c,u,s)),thunkify5(differenceWithArrayAsync,r,e,n,o,i)));y||o.push(t)}var c,u,s,f;return o},differenceWith=(r,e)=>function(n){if(isArray(n))return differenceWithArray(r,e,n);throw new TypeError(`${n} is not an Array`)};export default differenceWith;
