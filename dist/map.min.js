/**
 * rubico v1.9.2
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(n,t){"object"==typeof module?module.exports=t:"function"==typeof define?define((()=>t)):n.map=t}("object"==typeof globalThis?globalThis:this,function(){"use strict";const n=Symbol.iterator,t=(t,r)=>({toString:()=>"[object MappingIterator]",[n](){return this},next(){const n=t.next();return n.done?n:{value:r(n.value),done:!1}}}),r=n=>({value:n,done:!1}),o=n=>null!=n&&"function"==typeof n.then,e=Symbol.asyncIterator,c=(n,t)=>({[e](){return this},async next(){const e=await n.next();if(e.done)return e;const c=t(e.value);return o(c)?c.then(r):{value:c,done:!1}}}),u=Symbol.for("placeholder"),i=function(n,t,r){return t==u?((n,t)=>function(r){return n(r,t)})(n,r):((n,t)=>function(r){return n(t,r)})(n,t)},f=Array.isArray,s=Object.prototype.toString,l=n=>s.call(n),a=Promise.all.bind(Promise),h=function(n,t){const r=n.length,e=Array(r);let c=-1,u=!1;for(;++c<r;){const r=t(n[c],c,n);o(r)&&(u=!0),e[c]=r}return u?a(e):e},p=function(n,t,r,o){return t==u?((n,t,r)=>function(o){return n(o,t,r)})(n,r,o):r==u?((n,t,r)=>function(o){return n(t,o,r)})(n,t,o):((n,t,r)=>function(o){return n(t,r,o)})(n,t,r)},y=(n,t,r)=>n[t](r),d=n=>function(){return n},w=function(n,t,r,o,e){return t==u?((n,t,r,o)=>function(e){return n(e,t,r,o)})(n,r,o,e):r==u?((n,t,r,o)=>function(e){return n(t,e,r,o)})(n,t,o,e):o==u?((n,t,r,o)=>function(e){return n(t,r,e,o)})(n,t,r,e):((n,t,r,o)=>function(e){return n(t,r,o,e)})(n,t,r,o)},g=(n,t,r,o)=>n[t](r,o),b=n=>new Promise((n=>function(t){const r={};let e=0;for(const c in n){const u=n[c];o(u)?(e+=1,u.then((n=>function(o){r[n]=o,e-=1,0==e&&t(r)})(c))):r[c]=u}0==e&&t(r)})(n)),j=(n,t)=>function(...r){const e=n(...r);return o(e)?e.then(t):t(e)},m=function(n,t,r){return n[t]=r,n},A=async function(n,t,r,e){const c=n.length;for(;++e<c;){const c=t(n[e]);r[e]=o(c)?await c:c}return r},S=n=>function(...t){return n(...t),t[0]},O=Promise.race.bind(Promise),T=async function(n,t,r,e,c,u){const i=n.length;for(;++c<i;){u.size>=r&&await O(u);const i=t(n[c]);if(o(i)){const n=i.then(S((()=>u.delete(n))));u.add(n),e[c]=n}else e[c]=i}return a(e)},v=Object.prototype.hasOwnProperty,E=(n,t)=>v.call(n,t),M=(n,t,r)=>function(...o){const e=r.length,c=o.length,i=[];let f=-1,s=-1,l=0;for(;++f<e;){const e=r[f];if(e==u&&(s+=1)<c){const n=o[s];n==u&&(l+=1),i.push(n)}else i.push(e);if(i.length==n)return 0==l?t(...i):x(n,t,i)}for(;++s<c;){const r=o[s];if(r==u&&(l+=1),i.push(r),i.length==n)return 0==l?t(...i):x(n,t,i)}return x(n,t,i)},x=function(n,t,r){const o=r.length;if(o<n)return M(n,t,r);let e=-1;for(;++e<o;){if(r[e]==u)return M(n,t,r)}return t(...r)},P=n=>function([t,r]){return n(t,r)},$=function(n,t,r){return n.set(t,r)},I=function(n,t){const r=new Map,e=[];return n.forEach(((n,t,r)=>function(e,c){const u=n([c,e]);o(u)?r.push(u.then(P(x(3,$,[t])))):t.set(u[0],u[1])})(t,r,e)),0==e.length?r:a(e).then(d(r))},F=function(r,s){return f(r)?h(r,s):"function"==typeof r?(n=>"[object GeneratorFunction]"==l(n))(r)?((n,t)=>function*(...r){for(const o of n(...r))yield t(o)})(r,s):(n=>"[object AsyncGeneratorFunction]"==l(n))(r)?function(n,t){return async function*(...r){for await(const o of n(...r))yield t(o)}}(r,s):((n,t)=>function(r,e){const c=t(e);return o(c)?c.then(i(n,r,u)):n(r,c)})(r,s):null==r?r:"function"==typeof r.then?r.then(s):"function"==typeof r.map?r.map(s):"string"==typeof r||r.constructor==String?function(n,t){const r=h(n,t);return o(r)?r.then(p(y,u,"join","")):r.join("")}(r,s):r.constructor==Set?function(n,t){const r=new Set,e=[];for(const c of n){const i=t(c,c,n);o(i)?e.push(i.then(p(y,r,"add",u))):r.add(i)}return 0==e.length?r:a(e).then(d(r))}(r,s):r.constructor==Map?function(n,t){const r=new Map,e=[];for(const[c,i]of n){const f=t(i,c,n);o(f)?e.push(f.then(w(g,r,"set",c,u))):r.set(c,f)}return 0==e.length?r:a(e).then(d(r))}(r,s):"function"==typeof r[n]?t(r[n](),s):"function"==typeof r[e]?c(r[e](),s):r.constructor==Object?function(n,t){const r={};let e=!1;for(const c in n){const u=t(n[c],c,n);o(u)&&(e=!0),r[c]=u}return e?b(r):r}(r,s):s(r)},G=(...n)=>{const t=n.pop();return n.length>0?F(n[0],t):i(F,u,t)};return G.entries=function(n){return function(t){if(null==t)throw new TypeError("value is not an Object or Map");if(t.constructor==Object)return function(n,t){const r={},e=[];for(const c in n){const u=t([c,n[c]]);o(u)?e.push(u.then(P(x(3,m,[r])))):r[u[0]]=u[1]}return 0==e.length?r:a(e).then(d(r))}(t,n);if(t.constructor==Map)return I(t,n);throw new TypeError("value is not an Object or Map")}},G.series=n=>function(t){if(f(t))return function(n,t){const r=n.length,e=Array(r);let c=-1;for(;++c<r;){const r=t(n[c]);if(o(r))return r.then(j(p(m,e,c,u),w(A,n,t,u,c)));e[c]=r}return e}(t,n);throw new TypeError(`${t} is not an Array`)},G.pool=(n,t)=>function(r){if(f(r))return function(n,t,r){const e=n.length,c=Array(e);let u=-1;for(;++u<e;){const e=t(n[u]);if(o(e)){const o=new Set,i=e.then(S((()=>o.delete(i))));return o.add(i),c[u]=i,T(n,t,r,c,u,o)}c[u]=e}return c}(r,t,n);throw new TypeError(`${r} is not an Array`)},G.withIndex=n=>function(t){if(f(t))return function(n,t){const r=n.length,e=Array(r);let c=-1,u=!1;for(;++c<r;){const r=t(n[c],c,n);o(r)&&(u=!0),e[c]=r}return u?a(e):e}(t,n);throw new TypeError(`${t} is not an Array`)},G.own=n=>function(t){if((n=>{if(null==n)return!1;const t=typeof n;return"object"==t||"function"==t})(t)&&!f(t))return function(n,t){const r={};let e=!1;for(const c in n)if(E(n,c)){const u=t(n[c]);o(u)&&(e=!0),r[c]=u}return e?b(r):r}(t,n);throw new TypeError(`${t} is not an Object`)},G}());
