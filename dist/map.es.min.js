/**
 * rubico v2.6.1
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,symbolIterator=Symbol.iterator,MappingIterator=(r,e)=>({toString:()=>"[object MappingIterator]",[symbolIterator](){return this},next(){const t=r.next();return t.done?t:{value:e(t.value),done:!1}}}),NextIteration=r=>({value:r,done:!1}),symbolAsyncIterator=Symbol.asyncIterator,MappingAsyncIterator=(r,e)=>({[symbolAsyncIterator](){return this},async next(){const t=await r.next();if(t.done)return t;const n=e(t.value);return isPromise(n)?n.then(NextIteration):{value:n,done:!1}}}),__=Symbol.for("placeholder"),curry2ResolveArg0=(r,e)=>function(t){return r(t,e)},curry2ResolveArg1=(r,e)=>function(t){return r(e,t)},curry2=function(r,e,t){return e==__?curry2ResolveArg0(r,t):curry2ResolveArg1(r,e)},curry3ResolveArg0=(r,e,t)=>function(n){return r(n,e,t)},curry3ResolveArg1=(r,e,t)=>function(n){return r(e,n,t)},curry3ResolveArg2=(r,e,t)=>function(n){return r(e,t,n)},curry3=function(r,e,t,n){return e==__?curry3ResolveArg0(r,t,n):t==__?curry3ResolveArg1(r,e,n):curry3ResolveArg2(r,e,t)},isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const e=typeof r;return"object"==e||"function"==e},promiseAll=Promise.all.bind(Promise),arrayMap=function(r,e){const t=r.length,n=Array(t);let o=-1,s=!1;for(;++o<t;){const t=e(r[o],o,r);isPromise(t)&&(s=!0),n[o]=t}return s?promiseAll(n):n},callPropUnary=(r,e,t)=>r[e](t),stringMap=function(r,e){const t=arrayMap(r,e);return isPromise(t)?t.then(curry3(callPropUnary,__,"join","")):t.join("")},always=r=>function(){return r},setMap=function(r,e){const t=new Set,n=[];for(const o of r){const s=e(o,o,r);isPromise(s)?n.push(s.then(curry3(callPropUnary,t,"add",__))):t.add(s)}return 0==n.length?t:promiseAll(n).then(always(t))},curry4ResolveArg0=(r,e,t,n)=>function(o){return r(o,e,t,n)},curry4ResolveArg1=(r,e,t,n)=>function(o){return r(e,o,t,n)},curry4ResolveArg2=(r,e,t,n)=>function(o){return r(e,t,o,n)},curry4ResolveArg3=(r,e,t,n)=>function(o){return r(e,t,n,o)},curry4=function(r,e,t,n,o){return e==__?curry4ResolveArg0(r,t,n,o):t==__?curry4ResolveArg1(r,e,n,o):n==__?curry4ResolveArg2(r,e,t,o):curry4ResolveArg3(r,e,t,n)},callPropBinary=(r,e,t,n)=>r[e](t,n),mapMap=function(r,e){const t=new Map,n=[];for(const[o,s]of r){const i=e(s,o,r);isPromise(i)?n.push(i.then(curry4(callPropBinary,t,"set",o,__))):t.set(o,i)}return 0==n.length?t:promiseAll(n).then(always(t))},promiseObjectAllExecutor=r=>function(e){const t={};let n=0;for(const o in r){const s=r[o];isPromise(s)?(n+=1,s.then((r=>function(o){t[r]=o,n-=1,0==n&&e(t)})(o))):t[o]=s}0==n&&e(t)},promiseObjectAll=r=>new Promise(promiseObjectAllExecutor(r)),objectMap=function(r,e){const t={};let n=!1;for(const o in r){const s=e(r[o],o,r);isPromise(s)&&(n=!0),t[o]=s}return n?promiseObjectAll(t):t},funcConcat=(r,e)=>function(...t){const n=r(...t);return isPromise(n)?n.then(e):e(n)},objectSet=function(r,e,t){return r[e]=t,r},arrayMapSeriesAsync=async function(r,e,t,n){const o=r.length;for(;++n<o;){const o=e(r[n],n);t[n]=isPromise(o)?await o:o}return t},arrayMapSeries=function(r,e){const t=r.length,n=Array(t);let o=-1;for(;++o<t;){const t=e(r[o],o);if(isPromise(t))return t.then(funcConcat(curry3(objectSet,n,o,__),curry4(arrayMapSeriesAsync,r,e,__,o)));n[o]=t}return n},stringMapSeries=function(r,e){const t=arrayMapSeries(r,e);return isPromise(t)?t.then(curry3(callPropUnary,__,"join","")):t.join("")},thunkify4=(r,e,t,n,o)=>function(){return r(e,t,n,o)},_objectMapSeriesAsync=async function(r,e,t,n){for(const o in r){if(o in n)continue;let s=e(r[o]);isPromise(s)&&(s=await s),t[o]=s}return t},objectMapSeries=function(r,e){const t={},n={};for(const o in r){n[o]=!0;const s=e(r[o],o,r);if(isPromise(s))return s.then(funcConcat(curry3(objectSet,t,o,__),thunkify4(_objectMapSeriesAsync,r,e,t,n)));t[o]=s}return t},thunkify3=(r,e,t,n)=>function(){return r(e,t,n)},setAdd=function(r,e){return r.add(e),r},_setMapSeriesAsync=async function(r,e,t){let n=r.next();for(;!n.done;){let o=e(n.value);isPromise(o)&&(o=await o),t.add(o),n=r.next()}return t},setMapSeries=function(r,e){const t=new Set,n=r[symbolIterator]();let o=n.next();for(;!o.done;){const r=e(o.value);if(isPromise(r))return r.then(funcConcat(curry2(setAdd,t,__),thunkify3(_setMapSeriesAsync,n,e,t)));t.add(r),o=n.next()}return t},mapSet=function(r,e,t){return r.set(e,t)},_mapMapSeriesAsync=async function(r,e,t){let n=r.next();for(;!n.done;){let o=e(n.value[1]);isPromise(o)&&(o=await o),t.set(n.value[0],o),n=r.next()}return t},mapMapSeries=function(r,e){const t=new Map,n=r[symbolIterator]();let o=n.next();for(;!o.done;){const r=o.value[0],s=e(o.value[1]);if(isPromise(s))return s.then(funcConcat(curry3(mapSet,t,r,__),thunkify3(_mapMapSeriesAsync,n,e,t)));t.set(r,s),o=n.next()}return t},tapSync=r=>function(...e){return r(...e),e[0]},promiseRace=Promise.race.bind(Promise),arrayMapPoolAsync=async function(r,e,t,n,o,s){const i=r.length;for(;++o<i;){s.size>=t&&await promiseRace(s);const i=e(r[o]);if(isPromise(i)){const r=i.then(tapSync((()=>s.delete(r))));s.add(r),n[o]=r}else n[o]=i}return promiseAll(n)},arrayMapPool=function(r,e,t){const n=r.length,o=Array(n);let s=-1;for(;++s<n;){const n=t(r[s]);if(isPromise(n)){const i=new Set,c=n.then(tapSync((()=>i.delete(c))));return i.add(c),o[s]=c,arrayMapPoolAsync(r,t,e,o,s,i)}o[s]=n}return o},stringMapPool=function(r,e,t){const n=arrayMapPool(r,e,t);return isPromise(n)?n.then(curry3(callPropUnary,__,"join","")):n.join("")},_setMapPoolAsync=async function(r,e,t,n,o,s){let i=e.next();for(;!i.done;){s.size>=t&&await promiseRace(s);const c=n(i.value,i.value,r);if(isPromise(c)){const r=c.then((e=>{s.delete(r),o.add(e)}));s.add(r)}else o.add(c);i=e.next()}return s.size>0&&await promiseAll(s),o},setMapPool=function(r,e,t){const n=new Set,o=r[symbolIterator]();let s=o.next();for(;!s.done;){const i=t(s.value,s.value,r);if(isPromise(i)){const s=new Set,c=i.then((r=>{s.delete(c),n.add(r)}));return s.add(c),_setMapPoolAsync(r,o,e,t,n,s)}n.add(i),s=o.next()}return n},_mapMapPoolAsync=async function(r,e,t,n,o,s){let i=e.next();for(;!i.done;){s.size>=t&&await promiseRace(s);const c=i.value[0],a=n(i.value[1],c,r);if(isPromise(a)){o.set(c,a);const r=a.then((e=>{s.delete(r),o.set(c,e)}));s.add(r)}else o.set(c,a);i=e.next()}return s.size>0&&await promiseAll(s),o},mapMapPool=function(r,e,t){const n=new Map,o=r[symbolIterator]();let s=o.next();for(;!s.done;){const i=s.value[0],c=t(s.value[1],i,r);if(isPromise(c)){const s=new Set;n.set(i,c);const a=c.then((r=>{s.delete(a),n.set(i,r)}));return s.add(a),_mapMapPoolAsync(r,o,e,t,n,s)}n.set(i,c),s=o.next()}return n},_objectMapPoolAsync=async function(r,e,t,n,o,s){for(const i in r){if(i in o)continue;s.size>=e&&await promiseRace(s);const c=t(r[i],i,r);if(isPromise(c)){n[i]=c;const r=c.then((e=>{s.delete(r),n[i]=e}));s.add(r)}else n[i]=c}return s.size>0&&await promiseAll(s),n},objectMapPool=function(r,e,t){const n={},o={};for(const s in r){o[s]=!0;const i=t(r[s],s,r);if(isPromise(i)){const c=new Set;n[s]=i;const a=i.then((r=>{c.delete(a),n[s]=r}));return c.add(a),_objectMapPoolAsync(r,e,t,n,o,c)}n[s]=i}return n},_curryArity=(r,e,t)=>function(...n){const o=t.length,s=n.length,i=[];let c=-1,a=-1,u=0;for(;++c<o;){const o=t[c];if(o==__&&(a+=1)<s){const r=n[a];r==__&&(u+=1),i.push(r)}else i.push(o);if(i.length==r)return 0==u?e(...i):curryArity(r,e,i)}for(;++a<s;){const t=n[a];if(t==__&&(u+=1),i.push(t),i.length==r)return 0==u?e(...i):curryArity(r,e,i)}return curryArity(r,e,i)},curryArity=function(r,e,t){const n=t.length;if(n<r)return _curryArity(r,e,t);let o=-1;for(;++o<n;){if(t[o]==__)return _curryArity(r,e,t)}return e(...t)},spread2=r=>function([e,t]){return r(e,t)},objectMapEntries=function(r,e){const t={},n=[];for(const o in r){const s=e([o,r[o]]);isPromise(s)?n.push(s.then(spread2(curryArity(3,objectSet,[t])))):t[s[0]]=s[1]}return 0==n.length?t:promiseAll(n).then(always(t))},mapMapEntriesForEachCallback=(r,e,t)=>function(n,o){const s=r([o,n]);isPromise(s)?t.push(s.then(spread2(curryArity(3,mapSet,[e])))):e.set(s[0],s[1])},mapMapEntries=function(r,e){const t=new Map,n=[];return r.forEach(mapMapEntriesForEachCallback(e,t,n)),0==n.length?t:promiseAll(n).then(always(t))},_map=function(r,e){return isArray(r)?arrayMap(r,e):null==r?r:"function"==typeof r.then?r.then(e):"function"==typeof r.map?r.map(e):"string"==typeof r||r.constructor==String?stringMap(r,e):r.constructor==Set?setMap(r,e):r.constructor==Map?mapMap(r,e):"function"==typeof r[symbolIterator]?MappingIterator(r[symbolIterator](),e):"function"==typeof r[symbolAsyncIterator]?MappingAsyncIterator(r[symbolAsyncIterator](),e):r.constructor==Object?objectMap(r,e):e(r)},map=function(r,e){return null==e?curry2(_map,__,r):isPromise(r)?r.then(curry2(_map,__,e)):_map(r,e)},_mapEntries=(r,e)=>{if(null==r)throw new TypeError("value is not an Object or Map");if(r.constructor==Object)return objectMapEntries(r,e);if(r.constructor==Map)return mapMapEntries(r,e);throw new TypeError("value is not an Object or Map")};map.entries=function(r,e){return null==e?curry2(_mapEntries,__,r):isPromise(r)?r.then(curry2(_mapEntries,__,e)):_mapEntries(r,e)};const _mapSeries=function(r,e){if(isArray(r))return arrayMapSeries(r,e);if(null==r)throw new TypeError(`invalid collection ${r}`);if("string"==typeof r||r.constructor==String)return stringMapSeries(r,e);if(r.constructor==Set)return setMapSeries(r,e);if(r.constructor==Map)return mapMapSeries(r,e);if(r.constructor==Object)return objectMapSeries(r,e);throw new TypeError(`invalid collection ${r}`)};map.series=function(r,e){return null==e?curry2(_mapSeries,__,r):isPromise(r)?r.then(curry2(_mapSeries,__,e)):_mapSeries(r,e)};const _mapPool=function(r,e,t){if(isArray(r))return arrayMapPool(r,e,t);if(null==r)throw new TypeError(`invalid collection ${r}`);if("string"==typeof r||r.constructor==String)return stringMapPool(r,e,t);if(r.constructor==Set)return setMapPool(r,e,t);if(r.constructor==Map)return mapMapPool(r,e,t);if(r.constructor==Object)return objectMapPool(r,e,t);throw new TypeError(`invalid collection ${r}`)};map.pool=function(r,e,t){return null==t?curry3(_mapPool,__,r,e):isPromise(r)?r.then(curry3(_mapPool,__,e,t)):_mapPool(r,e,t)};export default map;
