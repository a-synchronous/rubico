/**
 * rubico v2.7.9
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2026 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,__=Symbol.for("placeholder"),curry2ResolveArg0=(r,o)=>function(t){return r(t,o)},curry2ResolveArg1=(r,o)=>function(t){return r(o,t)},curry2=function(r,o,t){return o==__?curry2ResolveArg0(r,t):curry2ResolveArg1(r,o)},isArray=Array.isArray,objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=r=>nativeObjectToString.call(r),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=r=>objectToString(r)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=r=>objectToString(r)==asyncGeneratorFunctionTag,promiseAll=Promise.all.bind(Promise),always=r=>function(){return r},arrayForEach=function(r,o){const t=r.length,n=[];let e=-1;for(;++e<t;){const t=o(r[e],e,r);isPromise(t)&&n.push(t)}return 0==n.length?r:promiseAll(n).then(always(r))},objectForEach=function(r,o){const t=[];for(const n in r){const e=o(r[n],n,r);isPromise(e)&&t.push(e)}return 0==t.length?r:promiseAll(t).then(always(r))},iteratorForEach=function(r,o){const t=[];for(const n of r){const r=o(n);isPromise(r)&&t.push(r)}return 0==t.length?r:promiseAll(t).then(always(r))},asyncIteratorForEach=async function(r,o){const t=[];for await(const n of r){const r=o(n);isPromise(r)&&t.push(r)}return 0==t.length?r:promiseAll(t).then(always(r))},symbolIterator=Symbol.iterator,symbolAsyncIterator=Symbol.asyncIterator,thunkify3=(r,o,t,n)=>function(){return r(o,t,n)},_arrayForEachSeriesAsync=async function(r,o,t){const n=r.length;for(;++t<n;){const n=o(r[t]);isPromise(n)&&await n}return r},arrayForEachSeries=function(r,o){const t=r.length;let n=-1;for(;++n<t;){const t=o(r[n],n,r);if(isPromise(t))return t.then(thunkify3(_arrayForEachSeriesAsync,r,o,n))}return r},_objectForEachSeriesAsync=async function(r,o,t){for(const n in r){if(n in t)continue;const e=o(r[n]);isPromise(e)&&await e}return r},objectForEachSeries=function(r,o){const t={};for(const n in r){t[n]=!0;const e=o(r[n],n,r);if(isPromise(e))return e.then(thunkify3(_objectForEachSeriesAsync,r,o,t))}return r},thunkify2=(r,o,t)=>function(){return r(o,t)},_iteratorForEachSeriesAsync=async function(r,o){let t=r.next();for(;!t.done;){const n=o(t.value);isPromise(n)&&await n,t=r.next()}return r},iteratorForEachSeries=function(r,o){let t=r.next();for(;!r.done;){const n=o(t.value);if(isPromise(n))return n.then(thunkify2(_iteratorForEachSeriesAsync,r,o));t=r.next()}return r},asyncIteratorForEachSeries=async function(r,o){for await(const t of r){const r=o(t);isPromise(r)&&await r}return r},_forEach=function(r,o){return isArray(r)?arrayForEach(r,o):null==r?r:"function"==typeof r.forEach?(r.forEach(o),r):"function"==typeof r[symbolIterator]?iteratorForEach(r[symbolIterator](),o):"function"==typeof r[symbolAsyncIterator]?asyncIteratorForEach(r[symbolAsyncIterator](),o):r.constructor==Object?objectForEach(r,o):r},forEach=function(r,o){return"function"==typeof r?curry2(_forEach,__,r):isPromise(r)?r.then(curry2(_forEach,__,o)):_forEach(r,o)},_forEachSeries=function(r,o){if(isArray(r))return arrayForEachSeries(r,o);if(null==r)throw new TypeError(`invalid collection ${r}`);if("function"==typeof r[symbolIterator])return iteratorForEachSeries(r[symbolIterator](),o);if("function"==typeof r[symbolAsyncIterator])return asyncIteratorForEachSeries(r[symbolAsyncIterator](),o);if(r.constructor==Object)return objectForEachSeries(r,o);throw new TypeError(`invalid collection ${r}`)};forEach.series=function(r,o){return"function"==typeof r?curry2(_forEachSeries,__,r):isPromise(r)?r.then(curry2(_forEachSeries,__,o)):_forEachSeries(r,o)};export default forEach;
