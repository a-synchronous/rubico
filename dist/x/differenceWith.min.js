/**
 * rubico v2.7.9
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2026 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(n,t){"object"==typeof module?module.exports=t:"function"==typeof define?define(()=>t):n.differenceWith=t}("object"==typeof globalThis?globalThis:this,function(){"use strict";const n=Symbol.for("placeholder"),t=function(t,r,e){return r==n?((n,t)=>function(r){return n(r,t)})(t,e):((n,t)=>function(r){return n(t,r)})(t,r)},r=function(t,r,e,o){return r==n?((n,t,r)=>function(e){return n(e,t,r)})(t,e,o):e==n?((n,t,r)=>function(e){return n(t,e,r)})(t,r,o):((n,t,r)=>function(e){return n(t,r,e)})(t,r,e)},e=(n,t,r)=>function(){return n(t,r)},o=(n,t,r,e,o,u)=>function(){return n(t,r,e,o,u)},u=(n,t,r)=>n?t():r(),i=n=>null!=n&&"function"==typeof n.then,f=Array.isArray,c=function(n){const t=n.then(n=>[n,t]);return t},s=Promise.race.bind(Promise),l=async function(n,t,r,e){const o=n.length;for(;++r<o;){const o=t(n[r]);if(i(o))e.add(c(o));else if(o)return!0}for(;e.size>0;){const[n,t]=await s(e);if(e.delete(t),n)return!0}return!1},a=function(n,t){const r=n.length;let e=-1;for(;++e<r;){const r=t(n[e]);if(i(r))return l(n,t,e,new Set([c(r)]));if(r)return!0}return!1},h=function(n,t){return n.push(t),n},y=(n,t)=>function(...r){return t(n(...r))},d=function(){},p=(Symbol.iterator,Symbol.asyncIterator,async function(r,e,o,u,f){const c=e.length;for(;++f<c;){const c=e[f];let s=a(o,t(r,c,n));i(s)&&(s=await s),s||u.push(c)}return u});return(c,s)=>function(l){if(f(l))return function(f,c,s){const l=c.length,b=[];let m=-1;for(;++m<l;){const l=c[m],g=a(s,t(f,l,n));if(i(g))return g.then(y(r(u,n,d,e(h,b,l)),o(p,f,c,s,b,m)));g||b.push(l)}return b}(c,s,l);throw new TypeError(`${l} is not an Array`)}}());
