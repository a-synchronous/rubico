/**
 * rubico v2.5.0
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const isPromise=r=>null!=r&&"function"==typeof r.then,funcConcat=(r,t)=>function(...e){const n=r(...e);return isPromise(n)?n.then(t):t(n)},symbolIterator=Symbol.iterator,MappingIterator=(r,t)=>({toString:()=>"[object MappingIterator]",[symbolIterator](){return this},next(){const e=r.next();return e.done?e:{value:t(e.value),done:!1}}}),NextIteration=r=>({value:r,done:!1}),symbolAsyncIterator=Symbol.asyncIterator,MappingAsyncIterator=(r,t)=>({[symbolAsyncIterator](){return this},async next(){const e=await r.next();if(e.done)return e;const n=t(e.value);return isPromise(n)?n.then(NextIteration):{value:n,done:!1}}}),__=Symbol.for("placeholder"),curry2ResolveArg0=(r,t)=>function(e){return r(e,t)},curry2ResolveArg1=(r,t)=>function(e){return r(t,e)},curry2=function(r,t,e){return t==__?curry2ResolveArg0(r,e):curry2ResolveArg1(r,t)},isArray=Array.isArray,isObject=r=>{if(null==r)return!1;const t=typeof r;return"object"==t||"function"==t},promiseAll=Promise.all.bind(Promise),arrayMap=function(r,t){const e=r.length,n=Array(e);let o=-1,s=!1;for(;++o<e;){const e=t(r[o],o,r);isPromise(e)&&(s=!0),n[o]=e}return s?promiseAll(n):n},curry3ResolveArg0=(r,t,e)=>function(n){return r(n,t,e)},curry3ResolveArg1=(r,t,e)=>function(n){return r(t,n,e)},curry3ResolveArg2=(r,t,e)=>function(n){return r(t,e,n)},curry3=function(r,t,e,n){return t==__?curry3ResolveArg0(r,e,n):e==__?curry3ResolveArg1(r,t,n):curry3ResolveArg2(r,t,e)},callPropUnary=(r,t,e)=>r[t](e),stringMap=function(r,t){const e=arrayMap(r,t);return isPromise(e)?e.then(curry3(callPropUnary,__,"join","")):e.join("")},always=r=>function(){return r},setMap=function(r,t){const e=new Set,n=[];for(const o of r){const s=t(o,o,r);isPromise(s)?n.push(s.then(curry3(callPropUnary,e,"add",__))):e.add(s)}return 0==n.length?e:promiseAll(n).then(always(e))},curry4ResolveArg0=(r,t,e,n)=>function(o){return r(o,t,e,n)},curry4ResolveArg1=(r,t,e,n)=>function(o){return r(t,o,e,n)},curry4ResolveArg2=(r,t,e,n)=>function(o){return r(t,e,o,n)},curry4ResolveArg3=(r,t,e,n)=>function(o){return r(t,e,n,o)},curry4=function(r,t,e,n,o){return t==__?curry4ResolveArg0(r,e,n,o):e==__?curry4ResolveArg1(r,t,n,o):n==__?curry4ResolveArg2(r,t,e,o):curry4ResolveArg3(r,t,e,n)},callPropBinary=(r,t,e,n)=>r[t](e,n),mapMap=function(r,t){const e=new Map,n=[];for(const[o,s]of r){const i=t(s,o,r);isPromise(i)?n.push(i.then(curry4(callPropBinary,e,"set",o,__))):e.set(o,i)}return 0==n.length?e:promiseAll(n).then(always(e))},promiseObjectAllExecutor=r=>function(t){const e={};let n=0;for(const o in r){const s=r[o];isPromise(s)?(n+=1,s.then((r=>function(o){e[r]=o,n-=1,0==n&&t(e)})(o))):e[o]=s}0==n&&t(e)},promiseObjectAll=r=>new Promise(promiseObjectAllExecutor(r)),objectMap=function(r,t){const e={};let n=!1;for(const o in r){const s=t(r[o],o,r);isPromise(s)&&(n=!0),e[o]=s}return n?promiseObjectAll(e):e},objectSet=function(r,t,e){return r[t]=e,r},arrayMapSeriesAsync=async function(r,t,e,n){const o=r.length;for(;++n<o;){const o=t(r[n],n);e[n]=isPromise(o)?await o:o}return e},arrayMapSeries=function(r,t){const e=r.length,n=Array(e);let o=-1;for(;++o<e;){const e=t(r[o],o);if(isPromise(e))return e.then(funcConcat(curry3(objectSet,n,o,__),curry4(arrayMapSeriesAsync,r,t,__,o)));n[o]=e}return n},stringMapSeries=function(r,t){const e=arrayMapSeries(r,t);return isPromise(e)?e.then(curry3(callPropUnary,__,"join","")):e.join("")},thunkify4=(r,t,e,n,o)=>function(){return r(t,e,n,o)},_objectMapSeriesAsync=async function(r,t,e,n){for(const o in r){if(o in n)continue;let s=t(r[o]);isPromise(s)&&(s=await s),e[o]=s}return e},objectMapSeries=function(r,t){const e={},n={};for(const o in r){n[o]=!0;const s=t(r[o],o,r);if(isPromise(s))return s.then(funcConcat(curry3(objectSet,e,o,__),thunkify4(_objectMapSeriesAsync,r,t,e,n)))}return e},thunkify3=(r,t,e,n)=>function(){return r(t,e,n)},setAdd=function(r,t){return r.add(t),r},_setMapSeriesAsync=async function(r,t,e){let n=r.next();for(;!n.done;){let o=t(n.value);isPromise(o)&&(o=await o),e.add(o),n=r.next()}return e},setMapSeries=function(r,t){const e=new Set,n=r[symbolIterator]();let o=n.next();for(;!o.done;){const r=t(o.value);if(isPromise(r))return r.then(funcConcat(curry2(setAdd,e,__),thunkify3(_setMapSeriesAsync,n,t,e)));e.add(r),o=n.next()}return e},mapSet=function(r,t,e){return r.set(t,e)},_mapMapSeriesAsync=async function(r,t,e){let n=r.next();for(;!n.done;){let o=t(n.value[1]);isPromise(o)&&(o=await o),e.set(n.value[0],o),n=r.next()}return e},mapMapSeries=function(r,t){const e=new Map,n=r[symbolIterator]();let o=n.next();for(;!o.done;){const r=o.value[0],s=t(o.value[1]);if(isPromise(s))return s.then(funcConcat(curry3(mapSet,e,r,__),thunkify3(_mapMapSeriesAsync,n,t,e)));e.set(r,s),o=n.next()}return e},tapSync=r=>function(...t){return r(...t),t[0]},promiseRace=Promise.race.bind(Promise),arrayMapPoolAsync=async function(r,t,e,n,o,s){const i=r.length;for(;++o<i;){s.size>=e&&await promiseRace(s);const i=t(r[o]);if(isPromise(i)){const r=i.then(tapSync((()=>s.delete(r))));s.add(r),n[o]=r}else n[o]=i}return promiseAll(n)},arrayMapPool=function(r,t,e){const n=r.length,o=Array(n);let s=-1;for(;++s<n;){const n=t(r[s]);if(isPromise(n)){const i=new Set,c=n.then(tapSync((()=>i.delete(c))));return i.add(c),o[s]=c,arrayMapPoolAsync(r,t,e,o,s,i)}o[s]=n}return o},_curryArity=(r,t,e)=>function(...n){const o=e.length,s=n.length,i=[];let c=-1,a=-1,u=0;for(;++c<o;){const o=e[c];if(o==__&&(a+=1)<s){const r=n[a];r==__&&(u+=1),i.push(r)}else i.push(o);if(i.length==r)return 0==u?t(...i):curryArity(r,t,i)}for(;++a<s;){const e=n[a];if(e==__&&(u+=1),i.push(e),i.length==r)return 0==u?t(...i):curryArity(r,t,i)}return curryArity(r,t,i)},curryArity=function(r,t,e){const n=e.length;if(n<r)return _curryArity(r,t,e);let o=-1;for(;++o<n;){if(e[o]==__)return _curryArity(r,t,e)}return t(...e)},spread2=r=>function([t,e]){return r(t,e)},objectMapEntries=function(r,t){const e={},n=[];for(const o in r){const s=t([o,r[o]]);isPromise(s)?n.push(s.then(spread2(curryArity(3,objectSet,[e])))):e[s[0]]=s[1]}return 0==n.length?e:promiseAll(n).then(always(e))},mapMapEntriesForEachCallback=(r,t,e)=>function(n,o){const s=r([o,n]);isPromise(s)?e.push(s.then(spread2(curryArity(3,mapSet,[t])))):t.set(s[0],s[1])},mapMapEntries=function(r,t){const e=new Map,n=[];return r.forEach(mapMapEntriesForEachCallback(t,e,n)),0==n.length?e:promiseAll(n).then(always(e))},_map=function(r,t){return isArray(r)?arrayMap(r,t):null==r?r:"function"==typeof r.then?r.then(t):"function"==typeof r.map?r.map(t):"string"==typeof r||r.constructor==String?stringMap(r,t):r.constructor==Set?setMap(r,t):r.constructor==Map?mapMap(r,t):"function"==typeof r[symbolIterator]?MappingIterator(r[symbolIterator](),t):"function"==typeof r[symbolAsyncIterator]?MappingAsyncIterator(r[symbolAsyncIterator](),t):r.constructor==Object?objectMap(r,t):t(r)},map=function(r,t){return"function"==typeof r?curry2(_map,__,r):isPromise(r)?r.then(curry2(_map,__,t)):_map(r,t)},_mapEntries=(r,t)=>{if(null==r)throw new TypeError("value is not an Object or Map");if(r.constructor==Object)return objectMapEntries(r,t);if(r.constructor==Map)return mapMapEntries(r,t);throw new TypeError("value is not an Object or Map")};map.entries=function(r,t){return"function"==typeof r?curry2(_mapEntries,__,r):isPromise(r)?r.then(curry2(_mapEntries,__,t)):_mapEntries(r,t)};const _mapSeries=function(r,t){if(isArray(r))return arrayMapSeries(r,t);if(null==r)throw new TypeError(`invalid collection ${r}`);if("string"==typeof r||r.constructor==String)return stringMapSeries(r,t);if(r.constructor==Set)return setMapSeries(r,t);if(r.constructor==Map)return mapMapSeries(r,t);if(r.constructor==Object)return objectMapSeries(r,t);throw new TypeError(`invalid collection ${r}`)};map.series=function(r,t){return"function"==typeof r?curry2(_mapSeries,__,r):isPromise(r)?r.then(curry2(_mapSeries,__,t)):_mapSeries(r,t)},map.pool=(r,t)=>function(e){if(isArray(e))return arrayMapPool(e,t,r);throw new TypeError(`${e} is not an Array`)};const memoizeCappedUnary=function(r,t){const e=new Map,n=function(n){if(e.has(n))return e.get(n);const o=r(n);return e.set(n,o),e.size>t&&e.clear(),o};return n.cache=e,n},pathDelimiters=/[.|[|\]]+/,parsePropertyPath=function(r){const t=r.length-1,e="["==r[0],n="]"==r[t];return e&&n?r.slice(1,t).split(pathDelimiters):e?r.slice(1).split(pathDelimiters):n?r.slice(0,t).split(pathDelimiters):r.split(pathDelimiters)},memoizedCappedParsePropertyPath=memoizeCappedUnary(parsePropertyPath,500),propertyPathToArray=r=>isArray(r)?r:"string"==typeof r?memoizedCappedParsePropertyPath(r):[r],getByPath=function(r,t){const e=propertyPathToArray(t),n=e.length;let o=-1,s=r;for(;++o<n;)if(s=s[e[o]],null==s)return;return s},_get=function(r,t,e){const n=null==r?void 0:getByPath(r,t);return void 0===n?"function"==typeof e?e(r):e:n},get=function(r,t,e){return"string"==typeof r||"number"==typeof r||isArray(r)?curry3(_get,__,r,t):isPromise(r)?r.then(curry3(_get,__,t,e)):_get(r,t,e)},pluck=function(...r){const t=r.pop(),e=get(t);return 0==r.length?map(e):map(r[0],e)};export default pluck;
