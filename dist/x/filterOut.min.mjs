/**
 * rubico v1.8.9
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2021 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */
const symbolIterator=Symbol.iterator,FilteringIterator=(r,t)=>({[symbolIterator](){return this},next(){let n=r.next();for(;!n.done;){const{value:e}=n;if(t(e))return{value:e,done:!1};n=r.next()}return n}}),isPromise=r=>null!=r&&"function"==typeof r.then,symbolAsyncIterator=Symbol.asyncIterator,FilteringAsyncIterator=(r,t)=>({isAsyncIteratorDone:!1,[symbolAsyncIterator](){return this},async next(){for(;!this.isAsyncIteratorDone;){const{value:n,done:e}=await r.next();if(e)this.isAsyncIteratorDone=!0;else{const r=t(n);if(isPromise(r)?await r:r)return{value:n,done:!1}}}return{value:void 0,done:!0}}}),isArray=Array.isArray,objectProto=Object.prototype,nativeObjectToString=objectProto.toString,objectToString=r=>nativeObjectToString.call(r),generatorFunctionTag="[object GeneratorFunction]",isGeneratorFunction=r=>objectToString(r)==generatorFunctionTag,asyncGeneratorFunctionTag="[object AsyncGeneratorFunction]",isAsyncGeneratorFunction=r=>objectToString(r)==asyncGeneratorFunctionTag,__=Symbol.for("placeholder"),curry4ResolveArg0=(r,t,n,e)=>function(o){return r(o,t,n,e)},curry4ResolveArg1=(r,t,n,e)=>function(o){return r(t,o,n,e)},curry4ResolveArg2=(r,t,n,e)=>function(o){return r(t,n,o,e)},curry4ResolveArg3=(r,t,n,e)=>function(o){return r(t,n,e,o)},curry4=function(r,t,n,e,o){return t==__?curry4ResolveArg0(r,n,e,o):n==__?curry4ResolveArg1(r,t,e,o):e==__?curry4ResolveArg2(r,t,n,o):curry4ResolveArg3(r,t,n,e)},promiseAll=Promise.all.bind(Promise),arrayExtendMap=function(r,t,n,e){const o=t.length;let i=r.length-1;for(;++e<o;)r[++i]=n(t[e],e,r);return r},arrayFilterByConditions=function(r,t,n,e){const o=r.length;let i=-1;for(;++n<o;)e[++i]&&t.push(r[n]);return t},arrayFilter=function(r,t){const n=r.length,e=[];let o=-1,i=-1;for(;++o<n;){const n=r[o],c=t(n);if(isPromise(c))return promiseAll(arrayExtendMap([c],r,t,o)).then(curry4(arrayFilterByConditions,r,e,o-1,__));c&&(e[++i]=n)}return e},generatorFunctionFilter=(r,t)=>function*(...n){yield*FilteringIterator(r(...n),t)},asyncGeneratorFunctionFilter=(r,t)=>async function*(...n){yield*FilteringAsyncIterator(r(...n),t)},curry3ResolveArg0=(r,t,n)=>function(e){return r(e,t,n)},curry3ResolveArg1=(r,t,n)=>function(e){return r(t,e,n)},curry3ResolveArg2=(r,t,n)=>function(e){return r(t,n,e)},curry3=function(r,t,n,e){return t==__?curry3ResolveArg0(r,n,e):n==__?curry3ResolveArg1(r,t,e):curry3ResolveArg2(r,t,n)},thunkify2=(r,t,n)=>function(){return r(t,n)},thunkConditional=(r,t,n)=>r?t():n(),always=r=>function(){return r},reducerFilter=(r,t)=>function(n,e){const o=t(e);return isPromise(o)?o.then(curry3(thunkConditional,__,(i=r,c=n,u=e,function(){return i(c,u)}),always(n))):o?r(n,e):n;var i,c,u},callPropUnary=(r,t,n)=>r[t](n),stringFilter=function(r,t){const n=arrayFilter(r,t);return isPromise(n)?n.then(curry3(callPropUnary,__,"join","")):n.join("")},thunkify1=(r,t)=>function(){return r(t)},noop=function(){},setFilter=function(r,t){const n=new Set,e=n.add.bind(n),o=[];for(const i of r){const c=t(i,i,r);isPromise(c)?o.push(c.then(curry3(thunkConditional,__,thunkify1(e,i),noop))):c&&n.add(i)}return 0==o.length?n:promiseAll(o).then(always(n))},thunkify4=(r,t,n,e,o)=>function(){return r(t,n,e,o)},callPropBinary=(r,t,n,e)=>r[t](n,e),mapFilter=function(r,t){const n=new Map,e=[];for(const[o,i]of r){const c=t(i,o,r);isPromise(c)?e.push(c.then(curry3(thunkConditional,__,thunkify4(callPropBinary,n,"set",o,i),noop))):c&&n.set(o,i)}return 0==e.length?n:promiseAll(e).then(always(n))},objectSetIf=function(r,t,n,e){e&&(r[t]=n)},objectFilter=function(r,t){const n={},e=[];for(const o in r){const i=r[o],c=t(i,o,r);isPromise(c)?e.push(c.then(curry4(objectSetIf,n,o,r[o],__))):c&&(n[o]=i)}return 0==e.length?n:promiseAll(e).then(always(n))},arrayExtendMapWithIndex=function(r,t,n,e){const o=t.length;let i=r.length-1;for(;++e<o;)r[++i]=n(t[e],e,t);return r},arrayFilterWithIndex=function(r,t){const n=r.length,e=[];let o=-1,i=-1;for(;++o<n;){const n=r[o],c=t(n,o,r);if(isPromise(c))return promiseAll(arrayExtendMapWithIndex([c],r,t,o)).then(curry4(arrayFilterByConditions,r,e,o-1,__));c&&(e[++i]=n)}return e},filter=r=>function(t){return isArray(t)?arrayFilter(t,r):"function"==typeof t?isGeneratorFunction(t)?generatorFunctionFilter(t,r):isAsyncGeneratorFunction(t)?asyncGeneratorFunctionFilter(t,r):reducerFilter(t,r):null==t?t:"string"==typeof t||t.constructor==String?stringFilter(t,r):t.constructor==Set?setFilter(t,r):t.constructor==Map?mapFilter(t,r):"function"==typeof t.filter?t.filter(r):"function"==typeof t[symbolIterator]?FilteringIterator(t[symbolIterator](),r):"function"==typeof t[symbolAsyncIterator]?FilteringAsyncIterator(t[symbolAsyncIterator](),r):t.constructor==Object?objectFilter(t,r):t};filter.withIndex=r=>function(t){if(isArray(t))return arrayFilterWithIndex(t,r);throw new TypeError(`${t} is not an Array`)};const _not=r=>!r,not=r=>function(t){if(null!=t&&"function"==typeof t.not)return t.not(r);const n=r(t);return isPromise(n)?n.then(_not):!n},notSync=r=>function(...t){return!r(...t)};not.sync=notSync;const filterOut=r=>filter(not(r));export default filterOut;
