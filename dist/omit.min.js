/**
 * rubico v1.6.13
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2020 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(t,n){"object"==typeof module?module.exports=n:"function"==typeof define?define((()=>n)):t.omit=n}("object"==typeof globalThis?globalThis:this,function(){"use strict";const t=Array.isArray,n=/[.|[|\]]+/,e=function(t,n){const e=new Map,o=function(o){if(e.has(o))return e.get(o);const c=t(o);return e.set(o,c),e.size>n&&e.clear(),c};return o.cache=e,o}((function(t){const e=t.length-1,o="["==t[0],c="]"==t[e];return o&&c?t.slice(1,e).split(n):o?t.slice(1).split(n):c?t.slice(0,e).split(n):t.split(n)}),500),o=n=>t(n)?n:"string"==typeof n?e(n):[n],c=function(t,n){const e=o(n),c=e.length-1;let r=-1,l=t;for(;++r<c;)if(l=l[e[r]],null==l)return;delete l[e[r]]},r=function(n){const e={};for(const o in n){const c=n[o];t(c)?e[o]=l(c):null!=c&&c.constructor==Object?e[o]=r(c):e[o]=c}return e},l=function(n){const e=n.length,o=[];let c=-1;for(;++c<e;){const e=n[c];t(e)?o[c]=l(e):null!=e&&e.constructor==Object?o[c]=r(e):o[c]=e}return o};return n=>function(e){if(null==e)return e;const o=n.length,s=t(i=e)?l(i):null==i?i:i.constructor==Object?r(i):i;var i;let u=-1;for(;++u<o;)c(s,n[u]);return s}}());
