/**
 * rubico v2.3.5
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2024 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(n,t){"object"==typeof module?module.exports=t:"function"==typeof define?define((()=>t)):n.set=t}("object"==typeof globalThis?globalThis:this,function(){"use strict";const n=n=>null!=n&&"function"==typeof n.then,t=Array.isArray,e=/[.|[|\]]+/,o=function(n,t){const e=new Map,o=function(o){if(e.has(o))return e.get(o);const r=n(o);return e.set(o,r),e.size>t&&e.clear(),r};return o.cache=e,o}((function(n){const t=n.length-1,o="["==n[0],r="]"==n[t];return o&&r?n.slice(1,t).split(e):o?n.slice(1).split(e):r?n.slice(0,t).split(e):n.split(e)}),500),r=function(n,e,r){if(!(n=>{if(null==n)return!1;const t=typeof n;return"object"==t||"function"==t})(n))return n;const i=(n=>t(n)?n:"string"==typeof n?o(n):[n])(r),u=i.length,c=u-1,f={...n};let s=f,l=-1;for(;++l<u;){const n=i[l];if(l==c)s[n]=e;else{const e=s[n],o=t(e)?e.slice():{...e};s[n]=o,s=o}}return f},i=Symbol.for("placeholder"),u=function(n,t,e,o){return t==i?((n,t,e)=>function(o){return n(o,t,e)})(n,e,o):e==i?((n,t,e)=>function(o){return n(t,o,e)})(n,t,o):((n,t,e)=>function(o){return n(t,e,o)})(n,t,e)},c=function(t,e,o){if("function"==typeof o){const c=o(t);return n(c)?c.then(u(r,t,i,e)):r(t,c,e)}return n(o)?o.then(u(r,t,i,e)):r(t,o,e)};return function(t,e,o){return null==o?u(c,i,t,e):n(t)?t.then(u(c,i,e,o)):c(t,e,o)}}());
