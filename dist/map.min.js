/**
 * rubico v2.3.0
 * https://github.com/a-synchronous/rubico
 * (c) 2019-2023 Richard Tong
 * rubico may be freely distributed under the MIT license.
 */

!function(n,t){"object"==typeof module?module.exports=t:"function"==typeof define?define((()=>t)):n.map=t}("object"==typeof globalThis?globalThis:this,function(){"use strict";const n=n=>null!=n&&"function"==typeof n.then,t=Symbol.iterator,r=(n,r)=>({toString:()=>"[object MappingIterator]",[t](){return this},next(){const t=n.next();return t.done?t:{value:r(t.value),done:!1}}}),e=n=>({value:n,done:!1}),o=Symbol.asyncIterator,u=(t,r)=>({[o](){return this},async next(){const o=await t.next();if(o.done)return o;const u=r(o.value);return n(u)?u.then(e):{value:u,done:!1}}}),c=Symbol.for("placeholder"),i=function(n,t,r){return t==c?((n,t)=>function(r){return n(r,t)})(n,r):((n,t)=>function(r){return n(t,r)})(n,t)},f=Array.isArray,s=Promise.all.bind(Promise),l=function(t,r){const e=t.length,o=Array(e);let u=-1,c=!1;for(;++u<e;){const e=r(t[u],u,t);n(e)&&(c=!0),o[u]=e}return c?s(o):o},h=function(n,t,r,e){return t==c?((n,t,r)=>function(e){return n(e,t,r)})(n,r,e):r==c?((n,t,r)=>function(e){return n(t,e,r)})(n,t,e):((n,t,r)=>function(e){return n(t,r,e)})(n,t,r)},a=(n,t,r)=>n[t](r),p=n=>function(){return n},y=function(n,t,r,e,o){return t==c?((n,t,r,e)=>function(o){return n(o,t,r,e)})(n,r,e,o):r==c?((n,t,r,e)=>function(o){return n(t,o,r,e)})(n,t,e,o):e==c?((n,t,r,e)=>function(o){return n(t,r,o,e)})(n,t,r,o):((n,t,r,e)=>function(o){return n(t,r,e,o)})(n,t,r,e)},d=(n,t,r,e)=>n[t](r,e),g=t=>new Promise((t=>function(r){const e={};let o=0;for(const u in t){const c=t[u];n(c)?(o+=1,c.then((n=>function(t){e[n]=t,o-=1,0==o&&r(e)})(u))):e[u]=c}0==o&&r(e)})(t)),w=(t,r)=>function(...e){const o=t(...e);return n(o)?o.then(r):r(o)},b=function(n,t,r){return n[t]=r,n},m=async function(t,r,e,o){const u=t.length;for(;++o<u;){const u=r(t[o]);e[o]=n(u)?await u:u}return e},j=n=>function(...t){return n(...t),t[0]},S=Promise.race.bind(Promise),v=async function(t,r,e,o,u,c){const i=t.length;for(;++u<i;){c.size>=e&&await S(c);const i=r(t[u]);if(n(i)){const n=i.then(j((()=>c.delete(n))));c.add(n),o[u]=n}else o[u]=i}return s(o)},A=(n,t,r)=>function(...e){const o=r.length,u=e.length,i=[];let f=-1,s=-1,l=0;for(;++f<o;){const o=r[f];if(o==c&&(s+=1)<u){const n=e[s];n==c&&(l+=1),i.push(n)}else i.push(o);if(i.length==n)return 0==l?t(...i):M(n,t,i)}for(;++s<u;){const r=e[s];if(r==c&&(l+=1),i.push(r),i.length==n)return 0==l?t(...i):M(n,t,i)}return M(n,t,i)},M=function(n,t,r){const e=r.length;if(e<n)return A(n,t,r);let o=-1;for(;++o<e;){if(r[o]==c)return A(n,t,r)}return t(...r)},T=n=>function([t,r]){return n(t,r)},x=function(n,t,r){return n.set(t,r)},E=function(t,r){const e=new Map,o=[];return t.forEach(((t,r,e)=>function(o,u){const c=t([u,o]);n(c)?e.push(c.then(T(M(3,x,[r])))):r.set(c[0],c[1])})(r,e,o)),0==o.length?e:s(o).then(p(e))},P=function(e,i){return f(e)?l(e,i):null==e?e:"function"==typeof e.then?e.then(i):"function"==typeof e.map?e.map(i):"string"==typeof e||e.constructor==String?function(t,r){const e=l(t,r);return n(e)?e.then(h(a,c,"join","")):e.join("")}(e,i):e.constructor==Set?function(t,r){const e=new Set,o=[];for(const u of t){const i=r(u,u,t);n(i)?o.push(i.then(h(a,e,"add",c))):e.add(i)}return 0==o.length?e:s(o).then(p(e))}(e,i):e.constructor==Map?function(t,r){const e=new Map,o=[];for(const[u,i]of t){const f=r(i,u,t);n(f)?o.push(f.then(y(d,e,"set",u,c))):e.set(u,f)}return 0==o.length?e:s(o).then(p(e))}(e,i):"function"==typeof e[t]?r(e[t](),i):"function"==typeof e[o]?u(e[o](),i):e.constructor==Object?function(t,r){const e={};let o=!1;for(const u in t){const c=r(t[u],u,t);n(c)&&(o=!0),e[u]=c}return o?g(e):e}(e,i):i(e)},O=(...t)=>{const r=t.pop();if(0==t.length)return i(P,c,r);const e=t[0];return n(e)?e.then(i(P,c,r)):P(e,r)};return O.entries=function(t){return function(r){if(null==r)throw new TypeError("value is not an Object or Map");if(r.constructor==Object)return function(t,r){const e={},o=[];for(const u in t){const c=r([u,t[u]]);n(c)?o.push(c.then(T(M(3,b,[e])))):e[c[0]]=c[1]}return 0==o.length?e:s(o).then(p(e))}(r,t);if(r.constructor==Map)return E(r,t);throw new TypeError("value is not an Object or Map")}},O.series=t=>function(r){if(f(r))return function(t,r){const e=t.length,o=Array(e);let u=-1;for(;++u<e;){const e=r(t[u]);if(n(e))return e.then(w(h(b,o,u,c),y(m,t,r,c,u)));o[u]=e}return o}(r,t);throw new TypeError(`${r} is not an Array`)},O.pool=(t,r)=>function(e){if(f(e))return function(t,r,e){const o=t.length,u=Array(o);let c=-1;for(;++c<o;){const o=r(t[c]);if(n(o)){const n=new Set,i=o.then(j((()=>n.delete(i))));return n.add(i),u[c]=i,v(t,r,e,u,c,n)}u[c]=o}return u}(e,r,t);throw new TypeError(`${e} is not an Array`)},O}());
